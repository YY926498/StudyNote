# 记录锁的隐含继承与释放

记录锁的自动继承与释放有3条规则：

- 锁与进程和文件两者相关联。这有两重含义：当一个进程终止时，它所建立的锁全部释放；第二重是无论一个描述符何时关闭，该进程通过这一描述符引用的文件上的任何一把锁都会释放（这些锁都是该进程设置）。例程：

~~~c
fd1=open(pathname,...);
read_lock(fd1,...);
fd2=dup(fd1);
close(fd2)
~~~

则在`close(fd2)`后，在`fd1`上设置的锁被释放，如果将`dup`替换成`open`，其效果也一样

~~~c
fd1=open(pathname,...);
read_lock(fd1,...);
fd2=open(pathname,...);
close(fd2)
~~~

- 由`fork`产生的子进程不继承父进程所设置的锁。即若一个进程得到一把锁，然后调用`fork`，那么对于父进程获得的锁，子进程被视为另一个进程。对于通过`fork`从父进程处继承而来的描述符，子进程需要调用`fcntl`才能获得它自己的锁。这个约束是有道理的，因为锁的作用是阻止多个进程同时写同一个文件。如果子进程通过`fork`继承父进程的锁，则父进程和子进程就可以同时写同一个文件。
- 在执行`exec`后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置了执行时关闭标志，那么当做为`exec`的一部分关闭该文件描述符时，将释放相应文件的所有锁。