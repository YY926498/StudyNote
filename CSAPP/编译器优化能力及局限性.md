# 编译器优化能力及局限性

编译器只能对程序使用安全的优化。

第一种情形：指针。由于多个指针有可能指向同一个位置，因此不能随意优化。

~~~c++
void twiddle1(long* xp,long* yp)
{
    *xp+=*yp;
    *xp+=*yp;
}
void  twiddle2(long* xp,long* yp)
{
    *xp+=2* *yp;
}
~~~

上述两个函数都是将存储在由指针`yp`指示的位置处 的值两次加到指针`xp`指示的位置处的值。另一方面，函数twiddle2效率更高一些。因为只需要3次内存引用（读`*xp`，读`*yp`，写`*xp`），而twiddle1需要6次。

但是，如果`xp==yp`（内存别名使用）时，两个函数由不同的结果，因此，这限制了优化.

第二种情形：函数调用。例如：

~~~c++
long f();

long func1()
{
    return f()+f()+f()+f();
}

long func2()
{
    return 4*f();
}

long count=0;

long f()
{
    return count++;
}
~~~

由于函数f有个副作用--修改全局程序状态的一部分。改变它的调用次数会改变程序的行为。因此，编译器会假设最糟的情形，并保持所有的函数调用不变。



可以使用内联函数替换优化函数调用：可以减少函数调用的开销，也允许对展开的代码进一步优化。但是不能对该函数的调用进行追踪或设置断点，并且不能用代码剖析的方式来评估程序性能。

另外在C++中，inline只是作为内联指示，不一定会被内联。





优化方式：

- 消除循环的低效率：代码移动：将计算结果不会改变的计算，移动到代码前面不会被多次求值的部分
- 减少过程调用
- 消除不必要的内存引用



循环展开：通过增加每次迭代计算的元素的数量，减少循环的迭代次数。

优点：减少了不直接有助于程序结果的操作的数量。并提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。



提高并行性：由于流水线可以每个时钟周期开始一个新的操作。



重新结合变换：调整运算顺序，但是不一定有效，需要谨慎使用。

另外，可以使用SSE指令（流SIMD扩展）或AVX。



但是，有如下限制：

1. 寄存器溢出：如果循环并行性的并行度超过可用寄存器数量，编译器会溢出，将部分临时值存放在内存中。
2. 分支预测和预测错误处罚：不要过分关心可预测的分支，书写适合条件传送实现的代码。



性能提高技术：

1. 高级设计：选择适当的算法和数据结构。
2. 基本编码原则：避免限制优化的因素，主要有

- 消除连续的函数调用，在可能时，将计算移到循环外。
- 消除不必要的内存引用。引入临时变量来保存中间结果。只有在最后的值计算出来的时候，才将结果存放到数组或全局变量中。
- 低级优化：结构化代码以利用硬件功能。主要有：展开循环，降低开销；使用多个累积变量和重新结合等技术，提高指令级并行；用功能性的风格重写条件操作，是的编译采用条件数据传送。



剖析软件：GPROF

~~~c
linux> gcc -0g -pg prog.c -o prog

linux> ./prog

linux> gprof prog
~~~

