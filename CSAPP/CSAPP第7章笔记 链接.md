# 第7章笔记 链接

### 编译器驱动程序

例如有main.c和sum.c两个c文件。使用GNU编译系统构造程序的过程如下：

- 在shell中输入下列命令来调用GCC驱动程序

`linux> gcc -0g -o prog main.c sum.c`

- 首先运行C预处理器(cpp)，将C的源程序main.c翻译成一个ASCII码的中间文件main.i

`cpp [other argument] main.c /tmp/main.i`

- 接下来驱动程序运行C编译器(cc1)，它将main.i翻译成一个ASCII汇编语言文件main.s

`cc1 /tmp/main.i -0g [other argument] -o /tmp/main.s`

- 然后，驱动程序运行汇编器(as)，它将一个main.s翻译成一个可重定位文件main.o

`as [other argument] -o /tmp/main.o /tmp/main.s`

- 驱动器经过相同的过程生成sum.o。最后，它运行链接器程序ld，将main.o 和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件prog

`ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o`

- 要运行可执行文件prog，在linux shell的命令行上输入它的名字，shell会调用操作系统的一个叫做加载器的函数，将可执行文件prog中的代码和数据复制到内存中，然后控制转移到这个程序的开头。



### 静态链接

类似Linux LD程序这样静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加在和运行的可执行目标文件作为输出。

链接器的主要任务：

- 符号解析：目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
- 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节（连续的字节序列，包括指令节、初始化的全局变量节、未初始化的变量节），然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。



目标文件纯粹是字节块的集合。这些块有些包含程序代码，有些包含程序数据，而其他的则包含引导连接器和加载器的数据结构。

### 目标文件

目标文件形式;

- 可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件
- 可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行
- 共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。



一个目标模块就是一个字节序列，一个目标文件就是一个以文件形式存放在磁盘中的目标模块。

### 可重定位目标文件

一个典型的ELF可重定位目标文件的格式为：

<table>
    <tr>
        <td rowspan="11"><center>节</center></td>    
        <td >ELF头</td>  
    </tr>
    <tr>
        <td >.text</td>  
    </tr>
    <tr>
        <td >.rodata</td>  
    </tr>
    <tr>
        <td >.data</td>  
    </tr>
    <tr>
        <td >.bss</td>  
    </tr>
    <tr>
        <td >.symtab</td>  
    </tr>
    <tr>
        <td >.rel.text</td>  
    </tr>
    <tr>
        <td >.rel.data</td>  
    </tr>
    <tr>
        <td >.debug</td>  
    </tr>
    <tr>
        <td >.line</td>  
    </tr>
    <tr>
        <td >.strtab</td>  
    </tr>
    <tr>
    	<td ><center>描述目标文件的节</center></td>
        <td >节头部表</td>  
    </tr>
</table>
其中.bss段存放未初始化的全局和静态变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际空间，它仅仅是一个占位符。

.debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。

### 符号和符号表

每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：

- 由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量
- 由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量
- 只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但不能被其他模块引用。

因此，在编程中尽可能用static属性来保护变量和函数。

ELF符号表条目:

~~~c
typedef struct
{
    int name;//String table offset
    char type:4,//Function or data(4 bits)使用位域
    	 binding:4;//Local or global(4 bits)
    char reserved;//Unused
    short section;//Section header index
    long value;//Section offset or absolute address
    long size;//Object size in bytes
}Elf64_Symbol;
~~~

有三个特殊的伪节：

- ABS：代表不该被重定位的符号
- UNDEF：代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号
- COMMON：还未被分配位置的未初始化的数据目标，对于COMMON符号，value给出对齐要求，size给出最小的大小。

只有可重定位目标文件才有这些伪节

COMMON：未初始化的全局变量

.bss：未初始化的静态变量，以及初始化为0的全局或静态变量。

### 符号解析

对于C++中重载的函数名，编译器会将每个唯一的函数和参数列表组合编码成一个对链接器来说唯一的名字。这种编码被称为重整(mangling)，相反的过程被称为恢复(demangling)。

函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

规则:

- 不允许有多个同名的强符号
- 如果有一个强符号和多个弱符号，那么选择强符号
- 如果有多个弱符号同名，那么从这弱符号中任意选取一个。

这就解释了为什么未初始化的全局变量放在COMMON节中。由于在某些情况下链接器允许多个模块定义同名的全局符号。当编译器在翻译某个模块时，遇到一个弱全局符号，比如说x，它并不知道其他模块是否定义了x，如果是，它无法预测链接器该使用x的多重定义中的哪一个。所以编译器把x分配成COMMON，把决定权留给链接器。另一方面，如果x初始化为0，那么它是一个强符号（因此根据规则2必须是唯一的），所以编译器可以很自信地把它分配成.bss。类似的，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成.data或.bss。

### 链接器使用静态库

由于链接器在链接时，会从左到右按照在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件，并且在扫描完一个文件后，不被需要的目标文件会简单的丢弃，因此，如果一个定义符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。

库一般是放在命令行的结尾，并且如果库之间有依赖关系，就必须进行排序。

### 记载可执行目标文件

每个Linux程序都有一个运行时内存映像，在Linux x86-64系统中，代码段总是从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址（${2^{48}} - 1$)开始，向较小内存地址增长。栈上的区域，从${2^{48}} $开始，是为内核中的代码和数据保留，所谓内核就是操作系统驻留在内存的部分。

### 动态链接共享库

在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程被称为动态链接。是由一个叫做动态链接器的程序来执行。

基本思路是：当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。