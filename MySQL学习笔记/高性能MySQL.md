# MySQL架构与历史

## MySQL逻辑架构

MySQL分为三层，第一层是客户端，包括连接处理、授权认证和安全等。

第二层是查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层包括存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层服务器的请求。

### 连接管理与安全性

每个客户端链连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。当客户端连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。

### 优化与执行

MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。可以通过特殊的关键字提示(hint)优化器，影响它的决策过程。也可以请求优化器解释(explain)优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效运行。

## 并发控制

MySQL在两个层面的并发控制：服务器层和存储引擎层。

### 读写锁

读锁是共享的，相互不阻塞。

写锁是排他的。

### 锁粒度

锁策略：在锁的开销和数据的安全性之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

**表锁**

是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表。一个用户对表进行写操作前，需要获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁具有更高的优先级。虽然存储引擎可以管理自己的锁，MySQL本身也会使用各种有效的表锁来实现不同的目的。比如，服务器会为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制。

**行级锁**

行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。

## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃会其他原因无法执行，那么所有的语句都不会执行。

ACID：原子性、一致性、隔离性和持久性。

**原子性**：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

**一致性**：数据库总是从一个一致性的状态转换到另一个一致性的状态。比如转账的时候，扣除了付款方的钱后，在转入到接收者的账号时出现问题，此时由于事务失败，事务中所做的修改不会保存到数据库中，付款方的钱还在其账户中。

**隔离性**：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。比如在转账时，当付款方同时分开支付多笔订单，每笔订单进行修改时，其余订单可能还看不到金额修改，但是具体分析要看事务的隔离级别。

**持久性**：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时，及时系统崩溃，修改的数据也不会丢失。分为不同的级别。

### 隔离级别

SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

**READ UNCOMMITTED（未提交读）**

在**READ UNCOMMITTED**级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。这个几倍会导致很多问题，从性能上来说，READ COMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

**READ COMMITTED（提交读）**

大多数数据库系统的默认隔离级别是**READ COMMITTED**（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。即：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做**不可重复读**，因为两次执行同样的查询，可能会得到不一样的结果。

**REPEATABLE READ（可重复读）**

**REPEATABLE READ**解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另一个**幻读**的问题。**幻读**：指的是当某个事务再次读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会出现**幻行**。`InnoDB`和`XtraDB`存储引擎通过多版本并发控制解决了幻读的问题。MySQL的默认事务隔离级别是可重复读。

**SERIALIZABLE（可串行化）**

**SERIALIZABLE**是最高的隔离级别。通过强制事务串行执行，避免了前面说的幻读的问题。简单地说，**SERIALIZABLE**会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

### 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

## MySQL的存储引擎

### InnoDB存储引擎

InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。

InnoDB表示基于聚簇索引建立的。二级索引中必须包含主键列。

### MyISAM存储引擎

不支持事务和行级锁，并且崩溃后无法安全恢复。

MyISAM会将表存放在两个文件中：数据文件和索引文件。可以包含动态或者静态行。

**特性**

-   加锁与并发：对整张表加锁。读取时对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表读取查询的同时，可以往表中插入新的记录（并发插入）。
-   修复：对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作。执行表的修复可能导致一些数据丢失，而且修复操作很慢。可以通过`CHECK TABLE mytable`检查表的错误。如果有错误可以执行`REPAIR TABLE mytable`进行修复。
-   索引特性：支持全文索引。
-   延迟更新索引键：如果指定了`DELAY_KEY_WRITE`选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是写到内存的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以极大地提升写入性能。

### 转换表的引擎

-   ALTER TABLE：`ALTER TABLE mytable ENGINE = InnoDB;`，该语句执行时间很长。MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。

如果转换表的存储引擎，将会丢失和原引擎相关的所有特性。如果将一张InnoDB表转换为MyISAM表，然后再转换回InnoDB，原InnoDB表上的所有外键就丢失。

-   导出与导入：可以使用mysqldump工具将数据导出到文件，然后修改文件中`CREATE TABLE`语句的存储引擎选项，注意同时修改表名，因为同一个数据库中不能存在相同的表名，即使使用不同的引擎。同时需要注意的是mysqldump默认自动在`CREATE TABLE`语句前加上`DROP TABLE`语句。
-   创建与查询：综合第一种方法的高效和第二种方法的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用`INSERT...SELECT`语法来导出数据。

~~~mysql
CREATE TABLE innodb_table LIKE myisam_table;
ALTER TABLE innodb_table ENGINE=InnoDB;
INSERT INTO innodb_table SELECT * FROM myisam_table;
~~~

如果数据量较小，这样做比较好。如果数据量很大，可以使用分批处理。针对每一段数据执行事务提交操作，以避免大事务产生过多的undo。



# 基准测试



# 服务器性能剖析

## 性能优化简介

性能即响应时间。性能优化是在一定的工作负载下尽可能地降低响应时间。

完成一项任务所需要的时间可以分为两部分：执行时间和等待时间。如果要优化任务的执行时间，最好的办法是通过测量定位不同的子任务花费的时间，然后优化去掉一些子任务、降低子任务的执行频率或者提升子任务的效率。

### 通过性能剖析进行优化

性能剖析：测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面。

### 理解性能剖析

-   值得优化的查询：如果优化的成本大于收益，就应当停止优化。
-   异常情况：某些任务由于一些副作用，需要特别优化。
-   丢失时间：任务的总时间和实际测量到的时间之间的差。
-   被掩藏的细节：比如任务执行时间直方图、百分比、标准差、偏差指数等。

## 对应用程序进行性能剖析





-   





