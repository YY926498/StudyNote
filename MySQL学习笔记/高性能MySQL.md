# MySQL架构与历史

## MySQL逻辑架构

MySQL分为三层，第一层是客户端，包括连接处理、授权认证和安全等。

第二层是查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层包括存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层服务器的请求。

### 连接管理与安全性

每个客户端链连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。当客户端连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。

### 优化与执行

MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。可以通过特殊的关键字提示(hint)优化器，影响它的决策过程。也可以请求优化器解释(explain)优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效运行。

## 并发控制

MySQL在两个层面的并发控制：服务器层和存储引擎层。

### 读写锁

读锁是共享的，相互不阻塞。

写锁是排他的。

### 锁粒度

锁策略：在锁的开销和数据的安全性之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

**表锁**

是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表。一个用户对表进行写操作前，需要获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁具有更高的优先级。虽然存储引擎可以管理自己的锁，MySQL本身也会使用各种有效的表锁来实现不同的目的。比如，服务器会为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制。

**行级锁**

行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。

## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃会其他原因无法执行，那么所有的语句都不会执行。

ACID：原子性、一致性、隔离性和持久性。

**原子性**：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

**一致性**：数据库总是从一个一致性的状态转换到另一个一致性的状态。比如转账的时候，扣除了付款方的钱后，在转入到接收者的账号时出现问题，此时由于事务失败，事务中所做的修改不会保存到数据库中，付款方的钱还在其账户中。

**隔离性**：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。比如在转账时，当付款方同时分开支付多笔订单，每笔订单进行修改时，其余订单可能还看不到金额修改，但是具体分析要看事务的隔离级别。

**持久性**：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时，及时系统崩溃，修改的数据也不会丢失。分为不同的级别。

### 隔离级别

SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

**READ UNCOMMITTED（未提交读）**

在**READ UNCOMMITTED**级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。这个几倍会导致很多问题，从性能上来说，READ COMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

**READ COMMITTED（提交读）**

大多数数据库系统的默认隔离级别是**READ COMMITTED**（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。即：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做**不可重复读**，因为两次执行同样的查询，可能会得到不一样的结果。

**REPEATABLE READ（可重复读）**

**REPEATABLE READ**解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另一个**幻读**的问题。**幻读**：指的是当某个事务再次读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会出现**幻行**。`InnoDB`和`XtraDB`存储引擎通过多版本并发控制解决了幻读的问题。MySQL的默认事务隔离级别是可重复读。

**SERIALIZABLE（可串行化）**

**SERIALIZABLE**是最高的隔离级别。通过强制事务串行执行，避免了前面说的幻读的问题。简单地说，**SERIALIZABLE**会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

### 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

## MySQL的存储引擎

### InnoDB存储引擎

InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。

InnoDB表示基于聚簇索引建立的。二级索引中必须包含主键列。

### MyISAM存储引擎

不支持事务和行级锁，并且崩溃后无法安全恢复。

MyISAM会将表存放在两个文件中：数据文件和索引文件。可以包含动态或者静态行。

**特性**

-   加锁与并发：对整张表加锁。读取时对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表读取查询的同时，可以往表中插入新的记录（并发插入）。
-   修复：对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作。执行表的修复可能导致一些数据丢失，而且修复操作很慢。可以通过`CHECK TABLE mytable`检查表的错误。如果有错误可以执行`REPAIR TABLE mytable`进行修复。
-   索引特性：支持全文索引。
-   延迟更新索引键：如果指定了`DELAY_KEY_WRITE`选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是写到内存的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以极大地提升写入性能。

### 转换表的引擎

-   ALTER TABLE：`ALTER TABLE mytable ENGINE = InnoDB;`，该语句执行时间很长。MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。

如果转换表的存储引擎，将会丢失和原引擎相关的所有特性。如果将一张InnoDB表转换为MyISAM表，然后再转换回InnoDB，原InnoDB表上的所有外键就丢失。

-   导出与导入：可以使用mysqldump工具将数据导出到文件，然后修改文件中`CREATE TABLE`语句的存储引擎选项，注意同时修改表名，因为同一个数据库中不能存在相同的表名，即使使用不同的引擎。同时需要注意的是mysqldump默认自动在`CREATE TABLE`语句前加上`DROP TABLE`语句。
-   创建与查询：综合第一种方法的高效和第二种方法的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用`INSERT...SELECT`语法来导出数据。

~~~mysql
CREATE TABLE innodb_table LIKE myisam_table;
ALTER TABLE innodb_table ENGINE=InnoDB;
INSERT INTO innodb_table SELECT * FROM myisam_table;
~~~

如果数据量较小，这样做比较好。如果数据量很大，可以使用分批处理。针对每一段数据执行事务提交操作，以避免大事务产生过多的undo。



# 基准测试



# 服务器性能剖析

## 性能优化简介

性能即响应时间。性能优化是在一定的工作负载下尽可能地降低响应时间。

完成一项任务所需要的时间可以分为两部分：执行时间和等待时间。如果要优化任务的执行时间，最好的办法是通过测量定位不同的子任务花费的时间，然后优化去掉一些子任务、降低子任务的执行频率或者提升子任务的效率。

### 通过性能剖析进行优化

性能剖析：测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面。

### 理解性能剖析

-   值得优化的查询：如果优化的成本大于收益，就应当停止优化。
-   异常情况：某些任务由于一些副作用，需要特别优化。
-   丢失时间：任务的总时间和实际测量到的时间之间的差。
-   被掩藏的细节：比如任务执行时间直方图、百分比、标准差、偏差指数等。



# Schema与数据类型优化

## 选择优化的数据类型

几个原则：

-   更小的通常更好
-   简单就好
-   尽量避免NULL：可为NULL的列使得索引、索引统计和值比较都更复杂。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。

在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。

下一步是选择具体类型。很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同、或者需要的物理空间不同。相同的大类型的不同子类型数据有时也有一些特殊的行为和属性。

例如，DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。然而TIMESTAMP只使用DATETIME一般的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TIMESTAMP允许的时间范围要小的多，有时它的特殊能力成为障碍。

MySQL中有很多别名。如果建表时采用数据类型的别名，然后用`SHOW CREATE TABLE`检查，会发现MySQL报告的是基本类型，不是别名。

### 整数类型

如果存储整数，可以使用如下类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。分别使用8,16,24,32,64位存储空间。

整数类型有可选的UNSIGNED属性，表示不允许负值。`TINYINT UNSIGNED`。

整数计算一般使用64位的BIGINT整数，但是一些聚合函数除外。

MySQL可以为整数类型指定宽度，例如`INT(11)`，它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显式字符的个数。对于存储和计算来说，`INT(1)`和`INT(20)`是相同的。

### 实数类型

实数是带有小数部分的数字。FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。而DECIMAL类型用于存储精确的小数。

浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。MySQL将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。例如`DECIMAL(18,9)`小数点两边各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。其中`DECIMAL`后面括号里的第一个数字表示总位数，第二个数字表示小数点后的数字长度。

DECIMAL类型允许最多65个数字。在计算中DECIMAL会转换成DOUBLE类型。

由于MySQL会自动选择不同的数据类型，或者在存储时对值进行取舍，因此不建议指定精度。

MySQL使用DOUBLE作为内部浮点计算的类型。

因为需要额外的空间和计算开销，应该尽量只在对小数进行精确计算时才使用DECIMAL-例如存储财务数据。但在数据量比较大的时候，考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。

### 字符串类型

**VARCHAR和CHAR类型**

这是两种最主要的字符串类型。

**VARCHAR**用于存储可变长字符串。比定长字符串更节省空间，因为仅使用必要的空间。但是，如果MySQL表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储，这会浪费空间。

VARCHAR需要使用1或2个字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，这是InnoDB则需要分裂页来使行可以放进页内。

**CHAR**是定长的：MySQL总是根据定义的字符串长度分配足够的空间。**当存储CHAR值时，MySQL会删除所有的末尾空格**。CHAR值会根据需要采用空格进行填充以方便比较。

数据如何存储取决于存储引擎，并非所有存储引擎会按照相同的方式处理定长和变长的字符串。Memory引擎只支持定长的行，即使有变长字段也会根据最大长度分配最大空间。不过，填充和截取空格的行为在不同存储引擎都是一样的，因为这是在MySQL服务器层进行处理的。

与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串。存储的是字节码。填充采用的是`\0`而不是空格，在检索时不会去掉填充值。

注：使用VARCHA(5)和VARCHAR(200)存储‘hello’的空间开销是一样的。但是使用更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序表进行排序时也同样糟糕。所以最好的策略是只分配真正需要的空间。

**BLOB和TEXT类型**

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

字符类型是TINYTEXT，SMALLTEXT，TEXT，MEDIUMTEXT，LONGTEXT，对应的二进制类型是TINYBLOB，SMALLBLOB，BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。

当BLOB和TEXT的值太大时，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1~4个字节来存储一个指针，然后在外部存储区域存储实际的值。

**BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。**

MySQL对BLOB和TEXT列进行排序：只对每个列的最前max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减少max_sort_length的配置，或者使用ORDER BY SUBSTRING(column,length)。

MySQL不能讲BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

**磁盘临时表和文件排序**

因为Memory引擎不支持BLOB和TEXT类型，所以，查询使用了BLOB和TEXT列并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，即使只有几行数据也是如此。最好的解决方案是尽量避免使用BLOB和TEXT类型。如果实在无法避免，有一个技巧是在所有用到BLOB字段的地方都使用SUBSTRING(column,length)将列值转换为字符串在ORDER BY子句中也适用。这样就可以使用内存临时表，但是要确保截取的子字符串足够短，不会使临时表的大小超过max_heap_table_size或tmp_table_size，超过以后，MySQL会将内存临时表转换为MyISAM磁盘临时表。

最坏的情况下的长度分配对于排序的时候也是一样。

**使用枚举代替字符串类型**

MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的`.frm`文件中保存`数字-字符串`映射关系的“查找表”。

例如：

~~~mysql
CREATE TABLE enum_test(
	e ENUM('fish','apple','dog') NOT NULL
);

INSERT INTO enum_test (e) VALUES ('fish'),('dog'),('apple');
SELECT e+0 FROM enum_test;//其中e+0结果变为数字

//结果：
1
3
2
~~~

**枚举字段是按照内部存储的整数而不是定义的字符串进行排序**

~~~mysql
SELECT e FROM enum_test ORDER BY e;
//结果
fish
apple
dog
~~~

一种绕过这种限制的方式是按照需要的顺序来定义枚举列。另外也可以在查询中使用FIELD()函数显式地指定排序顺序，但这会导致MySQL无法利用索引消除排序。

~~~mysql
SELECT e FROM enum_test ORDER BY FIELD(e,'apple','fish','dog');
~~~

枚举最不好的地方是：字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。除非能接受只在列表末尾添加元素。

### 日期和时间类型

**DATETIME**：保存范围为：1001年到9999年，精度为秒。把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。

**TIMESTAMP**：保存了从1970年1月1日午夜以来的秒数，和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，范围为1970年到2038年。提供FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。TIMESTAMP显式的值依赖于时区。

两者的区别：如果在多个时区存储或访问数据，TIMESTAMP和DATETIME的行为将很不一样。前者提供的值与时区有关，后者则只保留文本表示的日期和时间。

TIMESTAMP也有DATETIME没有的特殊属性。默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值，除非在UPDATE语句中明确指定了值。TIMESTAMP列默认为NOT NULL，这和其他数据类型不一样。

除了特殊行为之外，通常应该尽量使用TIMESTAMP，因为比DATETIME空间效率更高。

如果要存储比秒更小粒度的日期和时间值，可以使用BIGINT类型存储微妙级别的时间戳，或者使用DOUBLE存储秒之后的小数部分。

### 位数据类型

**BIT**

可以用BIT列在一列中存储一个或多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位，依次类推，BIT最大长度是64个位。

BIT的行为因存储引擎而异。MyISAM会打包存储所有的BIT列，所以17个单独的BIT列只需要17个位存储（假设没有可为NULL的列），这样MyISAM只使用3个字节就能存储这17个BIT列。其他存储引擎为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。

MySQL把BIT当做字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“1”或”0”。然而，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。如果需要和另外的值比较，一定要记得这一点。例如，如果存储一个值为b’00111001’（二进制等于57）到BIT(8)的列并且检索它，得到的内容是字符码为57的字符串。也就是说得到ASCII码为57的字符串”9”。但是在数字上下场景中，得到的是数字57。

~~~mysql
CREATE TABLE bittest(
	a bit(8) NOT NULL
);
INSERT INTO bittest(a) VALUES(b'00111001');
SELECT a,a+0 FROM bittest;
~~~



如果想在一个bit的存储空间中存储一个true/false值，另一个方法是创建一个可以为空的CHAR(0)列。该列可以保存空值(NULL)或者长度为零的字符串（空字符串）。

**SET**

如果需要保存很多true/false值，可以考虑合并列到一个SET数据类型，在MySQL内部是以一系列打包的位的集合来表示的。MySQL有像FIND_IN_SET()和FIELD()这样的函数，方便地在查询中使用。主要缺点是改变列的定义的代价较高：需要ALTER TABLE。一般来说，无法在SET列上通过索引查找。

~~~mysql
CREATE TABLE acl(
	perms SET('can_read','can_write','can_delete') NOT NULL
);
INSERT INTO acl (perms) VALUES('can_read,can_write');
SELECT perms FROM acl WHERE FIND_IN_SET('can_read',perms);

can_read,can_write
~~~

**在整数列上按位操作**

~~~mysql
SET 	@CAN_READ 	= 1<<0,
		@CAN_WRITE	= 1<<1,
		@CAN_DELETE	= 1<<2;
CREATE TABLE acl2(
	perms2 TINYINT UNSIGNED NOT NULL DEFAULT 0
);
INSERT INTO acl2(perms2) VALUES(@CAN_READ + @CAN_WRITE);
SELECT perms2 FROM acl2 WHERE perms2 & @CAN_READ;
~~~

### 选择标识符

为标识列选择合适的数据类型非常重要。一般来说更有可能用标识列与其他值进行比较，或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以为标识列选择数据类型时，应该选择跟关联表中的对应列一样的类型。

当选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑MySQL对这种类型怎么执行计算和比较。

一旦选定一种类型，要确保在所有关联表中都使用同样的类型。类型之间需要精确匹配，包括向UNSIGNED这样的属性。混用不同数据类型可能会导致性能问题。

在可以满足值的范围的需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。

**技巧**

-   整数类型：整数通常是标识列最好的选择，因为很快并且可以使用AUTO_INCREMENT。
-   ENUM和SET类型：适合存储固定信息，大部分情况下避免使用该类型作为标识列类型
-   字符串类型：尽量避免使用字符串类型作为标识列，因为很消耗空间，通常比数字类型慢，尤其是在MyISAM表里。因为MyISAM默认对字符串使用压缩索引，导致查询慢得多。注意完全“随机”的字符串。原因如下：
    -   因为插入值会随机地写到索引的不同位置，所以是的INSERT语句更慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。
    -   SELECT语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
    -   随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的访问局部性原理失效。如果整个数据集都一样的“热”，那么缓存任何一部分特定数据到内存都没有好处，如果工作机比内存大，缓存将会有很多刷新和不命中。

### 特殊的类型数据

某些类型的数据并不直接与内置类型一致。比如低于秒级精度的时间戳或者IP地址等。

## MySQL schema设计中的陷阱

**太多的列**

MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM的定长行结构实际上与服务器层的行结构正好匹配，所以不需要转换。然而，MyISAM的变长行结构和InnoDB的行结构则总是需要转换的。转换的代价依赖于列的数量。

**太多的关联**

所谓的“实体-属性-值”设计模式是一个常见的糟糕设计模式，尤其是在MySQL下不能靠谱地工作。MySQL限制了每个关联操作最多只能有61张表。如果希望查询执行得快速且并发性好，单个查询最好在12个表内做关联。

**全能的枚举**

注意防止过度使用枚举。

**变相的枚举**

枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值。有时候会更加混乱。

**Not Invent Here的NULL**

尽量避免使用NULL。但是确实需要表示未知值时可以使用NULL。 MySQL会在索引中存储NULL值，而Oracle不会。

## 范式和反范式

对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

**范式**

-   第一范式：属性的原子性即数据库中的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能重复的属性，如果出现重复的属性则需要重新构建实体，新的实体由重复的属性构成。
-   第二范式：属性完全依赖于主键，满足第二范式必须先满足第一范式，第二范式要求数据库的每个实例或行必须可以被唯一的区分，即表中要有一列属性可以将实体完全区分，这个属性就是主键，即每一个属性完全依赖于主键。完全依赖概念：即非主属性不能依赖于主键的部分属性，必须依赖于主键的所有属性。
-   第三范式：必须先满足第二范式，要求一个数据库表中不包含已在其他表中已包含的非主关键字信息。即非主属性之间不能函数依赖。避免数据冗余。

### 范式的优点

-   范式化的更新操作通常比反范式要快
-   当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
-   范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
-   很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句

范式化设计的schema的缺点是通常需要关联。这不但代价昂贵，也可能使一些索引策略无效。可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。

### 反范式的优点和缺点

反范式化的schema因为所有数据都在一张表中，可以很好地避免关联。

如果不需要关联表，则对大部分查询最差的情况--即使表没有使用索引--是全表扫描。当数据比内存大时这可能比关联要快的多，这样可以避免随机I/O。

### 混用范式化和反范式化

最常见的反范式化数据的方法是复制或者缓存，在不用的表中存储相同的特定列。可以使用触发器更新缓存值。

## 缓存表和汇总表

有时提升性能的最好的办法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一种完全独立的汇总表或缓存表。

缓存表表示存储那些可以比较简单地从schema其他表获取（但是每次获取速度较慢）数据的表。汇总表表示保存使用GROUP BY语句聚合数据的表。

一个有用的技巧是对缓存表使用不同的存储引擎。例如：如果主表使用InnoDB，用MyISAM作为缓存表的引擎将会得到更小的索引占用空间，并且可以做全文搜索。

在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。定期重建并不只是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引。

当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用。这可以通过使用“影子表”来实现，“影子表”指的是一张在真实表“背后”创建的表。当完成了建表操作后，可以通过一个原子重命名操作切换影子表和原表。

~~~mysql
DROP TABLE IF EXISTS my_summary_new, my_summary_old;
CREATE TABLE my_summary_new LIKE muy_summary;
RENAME TABLE my_summary TO my_summary_old, my_summary_new TO my_summary;
~~~

### 物化视图

物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

### 计数器表

假设有一个计数器表，只有一行数据，记录网站的点击次数：

~~~mysql
CREATE TABLE hit_counter(
	cnt int unsigned not null
)ENGINE=InnoDB;
~~~

网站每次点击都会导致对计数器进行更新：

~~~mysql
UPDATE hit_counter SET cnt = cnt+1;
~~~

问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁，这会使得这些事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。

~~~mysql
CREATE TABLE hit_counter(
	slot tinyint unsigned not null primary key,
    cnt int unsigned not null
)ENGINE=InnoDB;
~~~

然后预先在这张表中增加100行数据。现在任意选择一个随机的槽进行更新：

~~~mysql
UPDATE hit_counter SET cnt=cnt+1 WHERE slot = RAND()*100;
~~~

要获得统计结果，需要使用下面这样的聚合查询：

~~~mysql
SELECT SUM(cnt) FROM hit_counter;
~~~

## 加快ALTER TABLE操作的速度

MySQL的ALTER TABLE操作的的性能对大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除新表。

对常见的场景，能使用的技巧只有两种：

-   先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换
-   “影子拷贝”：用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。

不是所有的ALTER TABLE操作都会引起表重建。例如有两种方法可以改变或者删除一个列的默认值（一种很快，一种很慢）。比如修改一列的默认值：

很慢的方式：

~~~mysql
ALTER TABLE ska.film MODIFY COLUMN ren TINYINT(3) NOT NULL DEFAULT 5;
~~~

理论上，MySQL可以跳过创建新表的步骤。列的默认值实际上放在表的`.frm`文件中，所以可以直接修改这个文件而不需要改动表本身。然而MySQL还没有采用这种优化的方法，所有的MODIFY COLUMN操作都将导致表重建。

另一种方法：

~~~mysql
ALTER TABLE ska.film ALTER COLUMN ren SET DEFAULT 5;
~~~

这个语句会直接修改`.frm`文件而不涉及表数据。所以，这个操作是非常快的。

### 只修改`.frm`文件

下面操作是有可能不需要重建表的：（但是不是官方支持的）

-   移除（不是增加）一个列的AUTO_INCREMENT属性
-   增加、移除或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字串值。

基本的技术是为想要的表结构创建一个新的`.frm`文件，然后用它替换掉已经存在的那张表的`.frm`文件，像下面这样：

1.  创建一张有相同结构的空表，并进行所需要的的修改（例如增加ENUM常量）
2.  执行FLUSH TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止任何表被打开
3.  交换`.frm`文件
4.  执行UNLOCK TABLES来释放第2步的读锁。

示例：

为film表的rating列增加一个常量。

~~~mysql
CREATE TABLE IF NOT EXISTS film(
	Id int(8) NOT NULL AUTO_INCREMENT PRIMARY KEY,
	rating ENUM('G','PG','PG-13','R','NC-17') NOT NULL DEFAULT 'G'
)ENGINE = InnoDB,CHARSET=utf8mb4;

SHOW COLUMNS FROM web.film LIKE 'rating';

CREATE TABLE IF NOT EXISTS web.film_new LIKE web.film;
ALTER TABLE web.film_new
//注意ENUM新增变量应该放在最后，因为ENUM内部存储的是数值，如果增加在前面，将会导致一部分值的意思出现变化
MODIFY COLUMN rating ENUM('G','PG','PG-13','R','NC-17','PG-14')
DEFAULT 'G';
FLUSH TABLES WITH READ LOCK;
//在此时替换film的.frm文件
UNLOCK TABLES;
~~~

### 快速创建MyISAM索引

为了高效地载入数据到MyISAM表中，一个常用的技巧是先禁用索引、载入数据，然后重新启用索引：

~~~mysql
ALTER TABLE test.load_data DISABLE KEYS;
//载入数据
ALTER TABLE test.load_data ENABLE KEYS;
~~~

这个技巧是因为构建索引的工作被延迟到数据完全载入以后，这个时候已经可以通过排序来构建索引，这样做会快很多，并且可以使得索引树的碎片更少。更紧凑。

但是，这个方法对唯一索引无效，因为DISABLE KEYS只对非唯一索引有效。MyISAM会在内存中构造唯一索引，并且为载入的每一行检查唯一性。一旦索引的大小超过了有效内存大小，载入操作就会变得越来越慢。

对InnoDB，也有类似的技巧，依赖于InnoDB的快速在线索引创建功能。即先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。这个方法是在已经知道所有数据都是有效的并且没有必要做唯一性检查时可以这样来操作。

操作步骤：

1.  用需要的表结构创建一张表，但是不包括索引。
2.  载入数据到表中以构建`.MYD`文件
3.  按照需要的结构创建另外一张空表，这次要包含索引。这会创建`.frm`和`.MYI`文件
4.  获取读锁并刷新锁
5.  重命名第二张表的`.frm`和`.MYI`文件，让MySQL认为是第一张表的文件
6.  释放读锁
7.  使用REPAIR TABLE来重建表的索引。该操作会通过排序来构建所有索引，包括唯一索引。

这个操作步骤对大表来说会快很多。

## 总结

设计原则：尽可能保持任何东西小而简单总是好的。一些原则如下：

-   尽量避免过度设计，例如会导致极其复杂的schema设计，或者有很多列的表设计
-   使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用NULL值
-   尽量使用相同的数据类型存储相似或相关的值，尤其要在关联条件中使用的列
-   注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。
-   尽量使用整数定义标识列
-   避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显式宽度
-   小心使用ENUM和SET。虽然他们使用起来很方便，但是不要滥用，否则有时候会变成陷阱。最好避免使用BIT。



# 创建高性能的索引

索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。

索引优化是对查询性能优化的最有效的手段。能够轻易将查询性能提高几个数量级。创建一个真正“最优”的索引经常需要重写查询。

## 索引基础

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。

### 索引的类型

在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。

**B-Tree索引**

一般用的是**B+Tree**，即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。

**B-Tree**应用较多，MySQL的CREATE TABLE和其他语句中也使用该关键字。但是底层的存储引擎可能使用不同的存储结构。

存储引擎以不同的方式使用B-Tree索引。MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

**B-Tree**索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。叶子节点指向被索引的数据，而不是其他的节点页。

**B-Tree**对索引时顺序组织存储的，所以很适合查找范围数据。

例如：

~~~mysql
CREATE TABLE people(
	last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob data	not null,
    gender enum('m','f') not null,
    key(last_name, first_name,dob)
);
~~~

对于表中的每一行数据，索引中包含了last_name，first_name和dob的值。

注：索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。

**B-Tree**索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。

**全值匹配**

全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen、出生于1960-01-01的人。

**匹配最左前缀**

前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列

**匹配列前缀**

也可以只匹配某一列的值的开头部分。例如前面提到的索引索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。

**精确匹配某一列并范围匹配另外一列**

前面提到的索引可以用于查找所有姓为Allen，并且名字是字母K开头的人，即第一列last_name全匹配，第二列first_name范围匹配。

注：B-Tree通常可以支持“只访问索引的查询”，即查询只需访问索引，而无须访问数据行。

一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。

下面是关于B-Tree索引的限制

-   如果不是按照索引的最左列开始查找，则无法使用索引。例如上面的例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。
-   不能跳过索引中的列。即前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名(first_name)，则MySQL只能使用索引的列。
-   如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询`WHERE last_name = ‘Smith’ AND first_name LIKE ‘%J' AND dob = ‘1976-12-23’`，这个查询只能使用索引的前两列，因为这里的LIKE是一个范围条件（但是服务器可以把其他列用于其他目的）。如果范围查询的列值的数量是有限，那么可以通过多于等于条件来代替范围条件。

**哈希索引**

哈希索引只有精确匹配所有列的查询才有效。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

在MySQL中，只有Memory引擎显式支持哈希索引。这是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。另外，Memory引擎是支持非唯一哈希索引的。使用开链法。

例子：

~~~mysql
CREATE TABLE testhash(
	fname	varchar(50)	not null,
    lname	varchar(50)	not null,
    KEY	using hash(fname)
)ENGINE=MEMORY;
~~~

哈希索引只需存储对应的哈希值，因此索引的结构十分紧凑，所以哈希索引查找的速度非常快，但是也有限制：

-   哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行速度很快，所以大部分情况下这一点对性能的影响并不明显。
-   哈希索引数据并不是按照索引值顺序存储的，所以也就无法排序。
-   哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列(A,B)上建立哈希索引，如果查询只有数据列A则无法使用该索引。
-   哈希索引只支持等值比较查询，包括=、IN()、<=>（注意<>和<=>是不同的操作，<=>是专门判断值是否等于NULL，如果值等于NULL，返回1，否则为0）。也不支持任何范围查询，例如`WHERE price > 100`。
-   访问哈希索引的数据非常快，除非有哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中的所有的行指针，逐行进行比较，直到找到所有符合条件的行。
-   如果哈希冲突很多的话，一些索引维护操作的代价非常高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

因为这些限制，哈希索引只适用于某些特定的场合。而一旦适合哈希索引，则它带来的性能提升非常显著。

InnoDB引擎中有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为。

**创建自定义哈希索引**：如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引。

思路：在B-Tree基础上创建一个伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用B-Tree进行查找，但是它使用哈希值而不是键不慎进行索引查找。需要做的就是在查询的WHERE子句中手动指定使用哈希函数。

例如:

~~~mysql
SELECT id FROM url WHERE url = "http://www.mysql.com";
//删除原来URL列上的索引，而新增一个url_crc列，使用crc32做哈希
SELECT id FROM url WHERE url = "http://www.mysql.com"
	AND url_crc = CRC32("http://www.mysql.com");
~~~

这样做性能较高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找。

这样实现的缺陷是需要维护哈希值。可以手动维护，也可以使用触发器实现。

~~~mysql
CREATE TABLE pseudohash(
	id int unsigned NOT NULL auto_increment,
    url varchar(255) NOT NULL,
    url_crc int unsigned NOT NULL DEFAULT 0,
    PRIMARY KEY(id)
);
DELIMITER	//
CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN SET NEW.url_crc = crc32(NEW.url);
END;
//

CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON pseudohash FOR ROW BEGIN SET NEW.url_crc = crc32(NEW.url);
END;
DELIMITER ;
~~~

如果采用这种方式，记住不要使用SHA1()和MD5()作为哈希函数。因为这两个函数计算出来的哈希值是非常长的字符串，会浪费大量空间，比较时也会更慢。

**处理哈希冲突**：当使用哈希索引进行查询的时候，必须在WHERE子句中包含常量值。

**空间数据索引(R-Tree)**

MyISAM表支持空间索引，可以用作地理数据存储。这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。

**全文索引**

这是一种特殊类型的索引，查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。全文索引更类似于搜索引擎做的事，而不是简单地WHERE条件匹配。

在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

**其他索引类别**

比如分形树索引、聚簇索引、覆盖索引等。

## 索引的优点

索引可以让服务器快速地定位到表的指定位置。但是这不是唯一作用。

最常见的B-Tree索引，按照顺序存储数据。索引有如下三个优点：

1.  索引大大减少了服务器需要扫描的数据量
2.  索引可以帮助服务器避免排序和临时表
3.  索引可以将随机I/O变为顺序I/O

**索引是最好的解决方案吗？**

索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。一般对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将随之增长。这是需要使用分区技术。

如果表的数据特别多，可以建立一个元数据表，用来查询需要用到的某些特性。

## 高性能的索引策略

### 独立的列

“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

始终将索引列单独放在比较符号的一侧。

### 前缀索引和索引选择性

索引的选择性：不重复的索引值（基数）和数据表的记录总数(#T)的比值，范围从1/#T到1之间。

如果需要索引很长的字符列，一个策略是模拟哈希索引。可以索引开始的部分字符，大大节约索引空间，从而提高索引效率。但是会降低索引的选择性。索引的选择性越高则查询的效率越高。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况 某个列的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀的“基数”应该接近于完整列的”基数“。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。另一个方法是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。只看平均选择性是不够的，需要考虑最坏情况下的选择性。

创建前缀索引：

~~~mysql
ALTER TABLE demo ADD KEY(demo.col(7));
~~~

其中col为demo表的一个字符串，这是选择前7个字节为前缀索引。

前缀索引是一种能使索引更小、更快的有效方法，但是有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。

有时候后缀索引也有用途，但是mysql原生不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器来维护这种索引。

### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL 使用：索引合并的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。

索引合并策略有时候是一种优化的结果，但实际上说明了表上的索引建的很糟糕：

-   当出现服务器对多个索引做相交操作时，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
-   当服务器需要对多个索引做联合操作时，通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。特别是对其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
-   优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则会忽略对并发性的影响。

可以通过参数optimizer_switch来关闭索引合并功能，也可以使用IGNORE INDEX提示让优化器忽略掉某些索引。

### 选择合适的索引列顺序

正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。

在一个多列的B-Tree索引中，索引列的顺序意味着首先按照最左列进行排序，其次是第二列，等等。所以索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。

所以多列索引的列顺序至关重要。

选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。这个建议在某些场景可能有帮助，但通常不如避免随机IO和排序那么重要。

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的，这时候索引的作用只是用于优化WHERE条件的查找。在这种情况下，这样设计的索引确实能够更快地过滤出需要的行，对于在WHERE子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体技术），也和查询条件的具体值有关，即值的分布有关。

比如：

~~~mysql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
~~~

这时候可以先跑一个查询，看看WHERE条件分支对应的数据基数有多大：

~~~mysql
SELECT SUM(staff_id = 2), SUM(customer_id = 584) FROM payment;
~~~

然后将对应条件值的数量较少的放在前面。但是这样做，查询的结果非常依赖于选定的具体值。

另一个方法是根据一些工具确定“最差查询”，然后按照上述方法选定的索引顺序。否则就按照经验法则来做，因为经验法则考虑的是全局基数和选择性，而不是某个具体查询。

~~~mysql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*) FROM payment;
~~~

当使用前缀索引的时候，在某些条件值的基数比正常值高。这时应该单独考虑。

**不要忘记WHERE子句中的排序、分组和范围条件等其他因素，这些因素可能对查询的性能造成非常大的影响。**

### 聚簇索引

聚簇索引不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上是同一个结构中保存了B-Tree索引和数据行。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。

因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。

对于InnoDB，叶子页包含了行的全部数据，但是节点页只包含了索引列。InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。

聚簇索引可能对性能有帮助，但也可能导致严重的性能问题。

聚簇索引的优点：

-   可以把相关数据保存在一起。这样只需要从磁盘读取少数的数据页就能获取某条数据。
-   数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。
-   使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

缺点：

-   聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部都存放在内存中，则访问的顺序就没那么重要，聚簇索引也没有什么优势。
-   插入速度严重依赖于插入顺序。按照主键的顺序插入时加载数据到InnoDB表中速度最快的方式。但是如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。
-   更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
-   基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。
-   聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
-   二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
-   二级索引访问需要两次索引查找，而不是一次。

由于二级索引中保存的是“行指针”的实质。即二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。对于InnoDB，自适应哈希索引能够减少这样的重复工作。

**InnoDB和MyISAM的数据分布对比**

聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。

MyISAM的数据分布：数据分布是按照行号0开始递增。因为行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行，当然，如果是变长的，用其他的策略。

然后主键的聚簇索引是按照主键的大小进行排序，然后主键的叶节点存放的不是行数据，而是行号，这样先通过聚簇索引获得行号，然后跳过固定字节数，获取行数据。二级索引跟其他索引没有区别，也是按照二级索引进行排序，二级索引的叶节点存放的也是行号。

事实上，MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为PRIMARY的唯一非空索引。

**对于InnoDB，聚簇索引“就是”表。聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。**

另外，跟MyISAM不同的是，InnoDB的二级索引和聚簇索引很不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值当做指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无须更新二级索引中的这个“指针”。（这里解释了前面聚簇索引的第六个缺点）

**在InnoDB表中按主键顺序插入行**

如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用AUTO_INCREMENT自增列，这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也更好。

最好避免随机的聚簇索引，特别是对于I/O密集型的应用。

当主键是顺序插入时，InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（默认15/16），下一条记录就会写入新的页中。

如果使用随机主键，缺点如下：

-   写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机I/O。
-   因为写入时乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂导致移动大量数据，一次插入最少需要修改三个页而不是一个页。
-   由于频繁地页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。

可能需要做一次OPTIMIZE TABLE来重建表并优化页的填充。

顺序的主键什么时候造成更坏的结果？

对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点是AUTO_INCREMENT锁机制，此时可能需要考虑重新设计表或应用，或者更改innodb_autoinc_lock_mode配置。

### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，称之为“覆盖索引”。

如果索引不需要回表，带来的好处有：

-   索引条目通常远小于数据行的大小，所以如果只需要读取索引，那么MySQL就会极大地减少数据访问量。覆盖索引对于I/O密集型也有好处，因为索引比数据更小，更容易全部放入内存中（由于是MyISAM，因为MyISAM能压缩索引以变得更小）。
-   因为索引是在单个页内按照列值顺序存储的，对于I/O密集型的范围查询比随机从磁盘读取每一行数据的I/O要少得多。
-   一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能导致严重的性能问题。
-   由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点保存了行的主键值，如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，索引MySQL只能使用B-Tree索引做覆盖索引。

索引覆盖查询有很多陷阱。假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段，可能不会使用覆盖索引。例：

~~~mysql
SELECT * FROM products WHERE actor = 'SEAN CARREY' AND title LIKE '%APOLLO%';
~~~

这个查询索引就会无法覆盖，原因为：

-   没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。不过可以使用索引找到对应的actor并检查出title是否匹配，过滤之后再读取需要的数据行。
-   MySQL不能再索引中执行LIKE操作。但是能在索引中做最左前缀匹配的LIKE比较，将其转化为简单的比较操作。

重写查询并巧妙地设计索引，先将索引扩展至覆盖三个数据列，然后用如下方式进行：

~~~mysql
SELECT * FROM products JOIN (SELECT prod_id FROM products WHERE actor = 'SEAN CARREY' AND title LIKE '%APOLLO%') AS t1 ON (t1.prod_id = products.prod_id);
~~~

这种方式叫做**延迟关联**，因为延迟了对列的访问。在查询的第一阶段MySQL可以用覆盖查询，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有的列值。

### 使用索引扫描来做排序

MySQL有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描。如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。

扫描索引本身很快，但是如果索引不能覆盖查询所需的全部列，就不得不每扫描一条索引记录就都回表查询一次对应的行。这些基本是随机I/O，因此按索引顺序读取数据的速度通常比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。**ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则，MySQL都需要执行排序操作，而无法利用索引排序。**

有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。

### 压缩（前缀压缩）索引

MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中。默认只压缩字符串，但可以通过参数设置对整数做压缩。

MyISAM压缩每个索引块的方法是：先完全保存索引块中的第一个值，然后把其他值和第一个值进行比较得到的相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如，索引块中的第一个值是“perform”，第二个值是”performance”，那么第二个值的前缀压缩后存储的是类似”7,ance”这样的形式。MyISAM对行指针也采用类似的前缀压缩方式。

压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描。正序的扫描速度还不错，但是如果是倒序扫描，所有在块中查找某一行的操作平均都需要扫描半个索引块。

### 冗余和重复索引

MySQL允许在相同列上创建多个索引。

**重复索引**是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免创建重复索引。

如果索引类型不同，并不算是重复索引，比如`KEY(col)`和`FULLTEXT KEY(col)`两种索引。

冗余索引和重复索引有些不同。如果创建索引`(A,B)`，再创建索引`(A)`就是冗余索引，因为这只是前一个索引的前缀索引。因此索引`(A,B)`也可以当做索引`(A)`来使用（这种冗余只是对B-Tree索引来说的）。但是如果再创建索引`(B,A)`则不是冗余索引，索引`(B)`也不是，因为`B`不是索引`(A,B)`的最左前缀列。另外，其他的不同类型的索引也不会是B-Tree索引的冗余索引。

大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。

一般来说，增加新索引会导致INSERT、UPDATE、DELETE等操作的速度变慢，特别是当新增索引后导致达到了内存瓶颈的时候。

### 未使用的索引

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这些索引建议删除。

### 索引和锁

索引可以让查询锁定更少的行。InnoDB只有在访问的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。

即使使用了索引，InnoDB也可能锁住一些不需要的数据。如果不能使用索引查找和锁定行的话问题可能会更糟糕，MySQL会做全表扫描并锁住所有的行，而不管是不是需要。

**InnoDB在二级索引上使用共享锁，但访问主键索引需要排他锁。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢很多。**

## 索引案例学习

### 支持多种过滤条件

基本原则是：考虑表上所有的选项。当设计索引时，不要只为现有的查询考虑需要哪些索引，还需要考虑对查询进行优化。如果发现某些查询需要创建新索引，但是这个索引又会降低另一些查询的效率，此时应该同时优化查询和索引以找到最佳的平衡。

基本原则是：尽可能将需要做范围查询的列放到索引的后面，以便优化器能够使用尽可能多的索引列。

### 避免多个范围条件

对于范围条件查询，MySQL无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询”则没有这个限制。

### 优化排序

如果查询中需要翻页，并且翻页翻到比较靠后时查询可能非常慢：

~~~mysql
SELECT <cols> FROM profiles WHERE sex = 'M' ORDER BY rating LIMIT 10000,10;
~~~

此时无论如何创建索引，这种查询都是个严重的问题。反范式化、预先计算和缓存可能是解决这类查询的仅由策略。另一个更好的方法是限制用户能够翻页的数量。

## 维护索引和表

维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。

### 找到并修复损坏的表

使用`CHECK TABLE`通常能够找出大多数的表和索引的错误。

使用`REPAIR TABLE`命令来修复损坏的表，但不是所有存储引擎都支持该命令。如果存储引擎不支持，可以通过一个不做任何操作的`ALTER`操作来重建表。

如果InnoDB发生损坏，可以通过设置`innodb_force_recovery`参数进入InnoDB的强制恢复模式来修复数据。

### 更新索引统计信息

MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标是一个查询需要扫描多少行。如果表没有统计信息，或者统计信息不准确，优化器有可能做出错误的决定。可以通过`ANALYZE TABLE`来重新生成统计信息解决这个问题。

InnoDB在表首次打开，或者执行`ANALYZE TABLE`，抑或表的大小发生非常大的变化（大小变化超过1/16或者新插入了20亿行都会触发）的时候计算索引的统计信息。

### 减少索引和数据的碎片

如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就会更好。

表的数据存储可能碎片化，然而，数据存储的碎片化比索引更加复杂。有三种类型的数据碎片：

-   行碎片：数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
-   行间碎片：逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益。
-   剩余空间碎片：剩余空间碎片是指数据页中有大量的空余空间。浙江会导致服务器读取大量不需要的数据，从而造成浪费。

对于MyISAM表，这三类碎片都可能发生。但InnoDB不会出现短小的行碎片，InnoDB会移动短小的行并重写到一个片段中。

可以通过执行`OPTIMIZE TABLE`或者导出再导入的方式来重新整理数据。

## 总结

在选择索引和编写利用这些索引的查询时，有如下三个原则：

-   单行访问是很慢的。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多的工作。最好的读取块中能包含尽可能多的需要的行。使用索引可以创建位置引用以提升效率。
-   按顺序访问范围数据是很快的，这有两个原因：一，顺序I/O不需要多次磁盘寻道，所以比随机I/O要快的多。二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算。
-   索引覆盖查询很快。如果一个索引包含了查询需要的列，那么存储引擎就不再需要再回表查找行。避免大量的单行访问。



# 查询性能优化

