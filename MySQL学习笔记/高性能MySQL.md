# MySQL架构与历史

## MySQL逻辑架构

MySQL分为三层，第一层是客户端，包括连接处理、授权认证和安全等。

第二层是查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

第三层包括存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层服务器的请求。

### 连接管理与安全性

每个客户端链连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。当客户端连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。

### 优化与执行

MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等。可以通过特殊的关键字提示(hint)优化器，影响它的决策过程。也可以请求优化器解释(explain)优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效运行。

## 并发控制

MySQL在两个层面的并发控制：服务器层和存储引擎层。

### 读写锁

读锁是共享的，相互不阻塞。

写锁是排他的。

### 锁粒度

锁策略：在锁的开销和数据的安全性之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

**表锁**

是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表。一个用户对表进行写操作前，需要获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁具有更高的优先级。虽然存储引擎可以管理自己的锁，MySQL本身也会使用各种有效的表锁来实现不同的目的。比如，服务器会为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制。

**行级锁**

行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。

## 事务

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃会其他原因无法执行，那么所有的语句都不会执行。

ACID：原子性、一致性、隔离性和持久性。

**原子性**：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

**一致性**：数据库总是从一个一致性的状态转换到另一个一致性的状态。比如转账的时候，扣除了付款方的钱后，在转入到接收者的账号时出现问题，此时由于事务失败，事务中所做的修改不会保存到数据库中，付款方的钱还在其账户中。

**隔离性**：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。比如在转账时，当付款方同时分开支付多笔订单，每笔订单进行修改时，其余订单可能还看不到金额修改，但是具体分析要看事务的隔离级别。

**持久性**：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时，及时系统崩溃，修改的数据也不会丢失。分为不同的级别。

### 隔离级别

SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

**READ UNCOMMITTED（未提交读）**

在**READ UNCOMMITTED**级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。这个几倍会导致很多问题，从性能上来说，READ COMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

**READ COMMITTED（提交读）**

大多数数据库系统的默认隔离级别是**READ COMMITTED**（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。即：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做**不可重复读**，因为两次执行同样的查询，可能会得到不一样的结果。

**REPEATABLE READ（可重复读）**

**REPEATABLE READ**解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另一个**幻读**的问题。**幻读**：指的是当某个事务再次读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会出现**幻行**。`InnoDB`和`XtraDB`存储引擎通过多版本并发控制解决了幻读的问题。MySQL的默认事务隔离级别是可重复读。

**SERIALIZABLE（可串行化）**

**SERIALIZABLE**是最高的隔离级别。通过强制事务串行执行，避免了前面说的幻读的问题。简单地说，**SERIALIZABLE**会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

### 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

为了解决死锁





