# 《MySQL技术内幕 InnoDB存储引擎》

## 第1章 MySQL体系结构和存储引擎

MySQL主要由以下几部分组成：

- [ ] 连接池组件
- [ ] 管理服务和工具组件
- [ ] SQL接口组件
- [ ] 查询分析器组件
- [ ] 优化器组件
- [ ] 缓冲组件
- [ ] 插件式存储引擎
- [ ] 物理文件

 MySQL的存储引擎是基于表的，而不是数据库。

### InnoDB存储引擎

InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。通过使用多版本并发控制（MVCC）来获得高并发性。

对于表中数据的存储，InnoDB存储引擎采用了聚集的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此为主键。

### MyISAM存储引擎

MyISAM存储引擎不支持事务、表锁设计，支持全文索引。一个与众不同的地方是它的缓冲区只缓存（cache)索引文件，而不缓存数据文件。

### NDB存储引擎

特点是数据全部放在内存中，因此主键查找的速度极快，并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统。

NDB存储引擎的联结操作（JOIN）是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着联结操作需要巨大的网络开销，因此查询速度很慢。

### Memory存储引擎

将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。默认使用的是哈希索引，而不是B+树索引。

只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存。

MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘中。由于MyISAM不缓存数据文件，因此这是产生临时表的性能对于查询会有损失。

### Archive存储引擎

只支持INSERT和SELECT操作，使用zlib算法将数据行（row)进行压缩后存储，压缩比一般达到1:10。非常适合存储归档数据，如日志信息，Archive存储引擎使用行锁来实现高并发的插入操作，但本身并不是食物安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。

### Federated存储引擎

不存放数据，指示指向一台远程的MySQL数据库服务器上的表。

### Maria存储引擎

设计目标是取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。

---

## 第2章 InnoDB存储引擎

InnoDB是事务安全的MySQL存储引擎。特点是行锁设计、支持MVCC、支持外键、提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。

### 后台线程

InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。

**Master Thread**

Master Thread是一个非常核心的后台线程，主要负责将缓冲区中的数据一步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。

**IO Thread**

在InnoDB存储引擎中大量使用AIO来处理写IO请求，这样可以大大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理。分为四种类型：write、read、insert buffer和log。

**Purge Thread**

当事务提交后，其所使用的undolog可能不在需要，因此需要PurgeThread来回收已经使用并分配的undo页。

**Purge Cleaner Thread**

作用是将之前的脏页的刷新操作都放入到单独的线程中来完成。

### 内存

**缓冲池**

InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统。在数据库系统中，由于CPU和磁盘速度的差异，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。

缓冲池就是一块内存。在数据库读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页‘FIX’在缓冲区中、下一次再读到相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页、否则，读取磁盘上的页。

对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘中。通过Checkpoint的机制刷新回磁盘。

综上，缓冲池的大小直接影响数据库的整体性能。由于32位的操作系统的限制，在该系统下最多将该值设置为3G。也可以打开PAE选项来获得最大64G内存的支持。

对于InnoDB存储引擎，缓冲池的配置可以通过参数innodb_buffer_pool_size来设置。

~~~mysql
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
~~~

结果：

~~~mysql
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| innodb_buffer_pool_size | 8388608 |
+-------------------------+---------+
~~~

缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲(insert buffer)、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。

每个页根据哈希值平均分配到不同的缓冲区实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。可以通过innodb_buffer_pool_instances来进行设置，该值默认为1.

~~~mysql
SHOW VARIABLES LIKE 'innodb_buffer_pool_instances';
~~~

~~~mysql
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| innodb_buffer_pool_instances | 1     |
+------------------------------+-------+
~~~

### LRU List、Free List和Flush List

通常来说，数据库中的缓冲池是通过LRU算法来进行管理的。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中的尾端的页。

InnoDB存储引擎中，缓冲池中的页大小默认为16K，同样适用LRU算法对缓冲池进行管理。但是在InnoDB的存储引擎中，LRU列表中还加入了midpoint位置。即新访问的页，不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法在InnoDB存储引擎下称为midpoint insertion strategy。默认配置下，该点位置在LRU列表长度的5/8处。midpoint位置可由参数innodb_old_blocks_pct控制。

~~~mysql
SHOW VARIABLES LIKE 'innodb_old_blocks_pct';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_old_blocks_pct | 37    |
+-----------------------+-------+
~~~

从上面的例子可以看出，参数innoDB_old_blocks_pct的默认值是37，表示新读取的页插入到LRU列表尾端的37%的位置（差不多3/8的位置）。在InnoDB存储引擎中，把midpoint之后的列表称为old列表，之前的称为new列表。可以简单的理解为new列表中的页都是最活跃的热点数据。

不采用朴素的LRU算法的理由：直接将读取的页放入到LRU列表的首部，某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘。

另外，InnoDB存储引擎引入了另一个参数来进一步管理LRU列表，这个参数是innodb_old_blocks_time，用于表示页读取到的mid位置后需要等待多久才会被加入到LRU列表的热端。因此当需要执行上述所说的SQL操作时，可以通过下面的方法尽可能使LRU列表中的热点数据不被刷出。

~~~mysql
SET GLOBAL innodb_old_blocks_time = 1000;
~~~

如果预估自己的活跃热点数据不止63%，那么在执行SQL语句前，还可以通过下面的语句来减少热点页被刷出的概率：

~~~mysql
SET GLOBAL innodb_old_blocks_pct=20;
~~~

当数据库刚启动时，LRU列表是空的，即没有任何的页，都存放在FREE列表中。当需要从缓冲池中分页时，首先从FREE列表中查找是否有可用的空闲页，若有则将该页从FREE移到LRU列表中。当页从LRU的old部分加入到new部分时，称此时的操作为page made young，因为innodb_old_blocks_time的设置导致页没有从old部分移动到new部分的操作称为page not made young。可以通过SHOW ENGINE INNODB STATUS来观察LRU列表即Free列表的使用情况。

使用命令SHOW ENGINE INNODB STATUS;显示的不是当前的状态，而是过去某个时间范围内InnoDB存储引擎的状态。

InnoDB支持压缩页的功能，即将原本的16KB的页压缩为1KB、2KB、4KB和8KB。这些压缩页通过unzip_LRU列表进行管理。

unzip_LRU分配内存的步骤：

首先，在unzip_LRU列表中对 不同压缩页大小进行分别管理。其次，通过伙伴算法进行内存的分配。例如需要从缓冲池中申请页4KB的大小：



## 第4章 表

### InnoDB逻辑存储结构

所有数据都被逻辑地存放在一个空间中，称之为表空间。表空间由段、区、页组成。

### 表空间

表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有数据都存放在表空间中。默认情况下InnoDB存储引擎有一个共享表空间`ibdata1`，即所有数据都存放在这个表空间中。如果用户启用参数`innodb_file_per_table`，则每张表的数据可以单独放到一个表空间内。

如果启用`innodb_file_per_table`参数，每张表的表空间内存放的只是数据、索引和插入缓冲Bitmap页，其他类的数据，如回滚`undo`的信息，插入缓冲索引页、系统事务信息，二次写缓冲(2M，每次首先将2M分成2次顺序写到磁盘，然后再分成两次，写入到对应位置，避免写入时，系统宕机导致数据丢失)等还是存放在原来的共享表空间内。

假如因为产生大量undo信息，导致共享表空间增大，等到rollback时，空间不会缩小，但是master thread每10秒执行full purge操作时，会将那些空间标记为可用空间，供下次undo使用。

### 段

常见的段有数据段、索引段、回滚段等。数据段为B+树的叶子节点，索引段即为B+树的非叶子节点。

### 区

区是由连续的页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4~5个区。默认情况下，InnoDB存储引擎页的大小为16KB，即一个区中一共有64个连续的页。

如果使用`innodb_file_per_table`后，创建表的大小默认是96KB。区中是连续的64个页，创建的表的大小至少是1MB。原因是在每个段开始时，先用32个页大小的碎片页来存放数据，在使用完这些页之后才是64个连续页的申请。目的是对于一些小表或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

### 页

页是InnoDB磁盘管理的最小单位。常见的页类型有：

数据页、undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页