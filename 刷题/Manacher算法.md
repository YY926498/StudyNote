# [Manacher算法](https://segmentfault.com/a/1190000008484167)

算法过程分析：

由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。

举个例子：`s="abbahopxpo"`，转换为`s_new="$#a#b#b#a#h#o#p#x#p#o#"`（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文`abba`和一个奇回文`opxpo`，被转换为`#a#b#b#a#`和`#o#p#x#p#o#`，长度都转换成了**奇数**。

定义一个辅助数组`int p[]`，其中`p[i]`表示以 i 为中心的最长回文的半径，例如：

| i        | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   | 19   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| s_new[i] | $    | #    | a    | #    | b    | #    | b    | #    | a    | #    | h    | #    | o    | #    | p    | #    | x    | #    | p    | #    |
| p[i]     |      | 1    | 2    | 1    | 2    | 5    | 2    | 1    | 2    | 1    | 2    | 1    | 2    | 1    | 2    | 1    | 4    | 1    | 2    | 1    |

可以看出，`p[i] - 1`正好是原字符串中最长回文串的长度。

接下来的重点就是求解 p 数组，如下图：
![img](https://segmentfault.com/img/remote/1460000014416801?w=590&h=190)
设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是`mx = id + p[id]`。

假设我们现在求`p[i]`，也就是以 i 为中心的最长回文半径，如果`i < mx`，如上图，那么：

```
if (i < mx)  
    p[i] = min(p[2 * id - i], mx - i);
```

`2 * id - i`为 i 关于 id 的对称点，即上图的 j 点，而**p[j]表示以 j 为中心的最长回文半径**，因此我们可以利用`p[j]`来加快查找。

例：最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2：**

```c++
输入: "cbbd"
输出: "bb"
```

~~~c++
string longestPalindrome(string s) {
        if(s.size()<2)
            return s;
        string s1(2*s.size()+1,'`');
        for(int i=1;i<s1.size();i+=2)
        {
            s1[i]=s[i/2];
        }
        vector<int> p(s1.size(),1);
        int id=0;
        int mx=0;
        for(int i=1;i<s1.size();++i)
        {
            if(i<mx)
                p[i]=min(p[2*id-i],mx-i);
            else
                p[i]=1;
            while((i-p[i]>=0) && (i+p[i]<s1.size()) && s1[i-p[i]]==s1[i+p[i]])
                ++p[i];
            if(mx<(i+p[i]))
            {
                mx=i+p[i];
                id=i;
            }
        }
        mx=0;
        for(int i=1;i<p.size();++i)
        {
            if(mx<p[i])
            {
                mx=p[i];
                id=i;
            }
        }
        s=s1.substr(id-p[id]+1,2*p[id]-1);
        s1.clear();
        for(auto i:s)
        {
            if(i!='`')
                s1+=i;
        }
        return s1;
    }
~~~

时间复杂度是O(n)