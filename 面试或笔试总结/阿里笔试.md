## 阿里笔试-20200323

### 第一题：有n个人，现在可以从中任意选择m个人组成一队，从m个人中选择一个人作为队长。可以组成多少个队？（人员只要有一个不一样，或者队长不同，认为是不同的一队）并对1e9+7取模

例：2
队伍有：($1^.$)、($2^.$)、($1^.$，2)、(1,$2^.$)，输出4。

分析：从n个人中选择m个人，可用组合$C^m_n$，然后在m个人中选择一个人作为队长，则有m种情况。

因此res = (1*$C^1_n$ +2* $C^2_n$ + … +n*$C^n_n$ )%mod

~~~c++
#include <iostream>
const int mod = 1000000007;

long long lcd(long long a, long long b)
{
	return b == 0 ? a : lcd(b, a%b);
}

int zuhe(long long n, long long m)
{
	long long fenzi = 1, fenmu = 1;

	for (long long i = 1; i < m; ++i)
	{
		fenzi *= (n - i + 1);
		fenzi %= mod;
		fenmu *= i;
		fenmu %= mod;
		long long gongyinzi = lcd(fenzi, fenmu);
		fenzi /= gongyinzi;
		fenmu /= gongyinzi;
	}
	fenzi *= (n - m + 1);
	fenzi %= mod;

	return fenzi / fenmu;
}

int main(void)
{
	int n;
	std::cin >> n;
	long long  res = 0;
	for (int i = 1; i <= n; ++i)
	{
		res += zuhe(n, i);
		res %= mod;
	}
	std::cout << res << std::endl;
}
~~~

但是这样在数据量超大时，会明显超时。因此考虑使用一种快速的方法。
$res = 1*C_n^1 + 2*C_n^2 +  \cdots  + n*C_n^n\\
       = 1*\frac{n}{1} + 2*\frac{{n*(n - 1)}}{{1*2}} +  \cdots  + n*\frac{{1*2* \cdots *n}}{{1*2* \cdots *n}}\\
       = n(C_{n - 1}^{n - 1} + C_{n - 1}^{n - 2} +  \cdots  + C_{n - 1}^0)\\
       = n*{2^{n - 1}}$

另外一种分析：先选队长，有n种可能，再从n-1个人中选队员，每个人有可能选，有可能不选，有$2^{n - 1}$种可能。

因此，考虑使用快速幂。

~~~c++
int main(void)
{
	int n;
	std::cin >> n;
	long long  res = n;
	int i = n - 1;
	int yinzi = 2;
	while (i > 0)
	{
		if (i & 1 == 1)
		{
			res *= yinzi;
			res %= mod;
		}
		yinzi *= yinzi;
		yinzi %= mod;
		i >>= 1;
	}
	std::cout << res << std::endl;
}
~~~

### 第二题：有一个n行m列的迷宫，你要寻找从起点到终点的最小步数，你可以往上走，往下走，往左走，往右走，或者跳跃到对称点，但是你走的目标点不能有障碍物。对称点定义如下：当前坐标为(x,y)，对称点坐标为($x'$,$y'$)，有$x+x'=n+1$,$y+y'=m+1$。其中x的范围为1-n,y的范围为1-m。其中只能跳跃5次

迷宫共有四种情况：S：代表起点，E：代表终点，#：代表障碍物，`.`：代表正常。使用bfs，快速找到

~~~c++
#include <iostream>
#include <vector>
#include <string>
#include <queue>
int main(void)
{
	int n, m;
	std::cin >> n >> m;
	std::vector<std::string> migong(n);
	int x = 0, y = 0;
	bool flag = false;
	for (int i = 0; i < n; ++i)
	{
		std::cin >> migong[i];
		if (!flag)
		{
			size_t pos = migong[i].find('S');
			if (pos < m)
			{
				flag = true;
				x = i;
				y = pos;
			}
		}
	}
	std::queue<std::pair<int,std::pair<int, int>>> path;
	path.emplace(std::make_pair(5,std::make_pair(x, y)));
	int res = 0;

	while (!path.empty())
	{
		int count = path.size();
		bool flag = false;
		while (--count >= 0)
		{
			std::pair<int, std::pair<int, int>> curpos = path.front();
			path.pop();
			if (migong[curpos.second.first][curpos.second.second] == 'E')
			{
				flag = true;
				break;
			}
			if (migong[curpos.second.first][curpos.second.second] == '`' ||
				migong[curpos.second.first][curpos.second.second] == '#' ||
				curpos.first < 0)
				continue;
			migong[curpos.second.first][curpos.second.second] = '`';
			if (curpos.second.first > 0)
			{
				path.emplace(std::make_pair(curpos.first,
					std::make_pair(curpos.second.first - 1, curpos.second.second)));
			}
			if (curpos.second.first < n - 1)
			{
				path.emplace(std::make_pair(curpos.first,
					std::make_pair(curpos.second.first + 1, curpos.second.second)));
			}
			if (curpos.second.second > 0)
			{
				path.emplace(std::make_pair(curpos.first,
					std::make_pair(curpos.second.first, curpos.second.second - 1)));
			}
			if (curpos.second.second < m - 1)
			{
				path.emplace(std::make_pair(curpos.first,
					std::make_pair(curpos.second.first, curpos.second.second + 1)));
			}
			if (curpos.first > 0)
			{
				curpos.second.first = n - 1 - curpos.second.first;
				if (curpos.second.first < 0 || curpos.second.first >= n)
					continue;
				curpos.second.second = m - 1 - curpos.second.second;
				if (curpos.second.second < 0 || curpos.second.second >= m)
					continue;
				path.emplace(std::make_pair(curpos.first - 1,
					std::make_pair(curpos.second.first, curpos.second.second)));
			}
		}
		
		if (flag)
			break;
		++res;
	}
	if (res == 0)
		std::cout << -1 << std::endl;
	else
		std::cout << res << std::endl;
	return 0;
}
~~~

总结：面对笔试，还是无法快速想到解题方法。还需要针对二分查找、快速幂、bfs、dfs和dp做针对训练。

