# 创建守护进程

### fork

- 首先调用fork，然后终止父进程，留下子进程继续运行。如果本进程是从前台作为一个shell命令启动的，当父进程终止时，shell就认为该命令已执行完毕。这样子进程就自动在后台运行。另外，子进程继承了父进程的进程组ID，不过它有自己的进程ID。这就保证了子进程不是一个进程组的头进程，这是接下来调用setsid的必要条件

### setsid

- setsid是一个POSIX函数，用于创建一个新的会话（session)。当前进程变为新会话的会话头进程以及新进程组的进程组头进程，从而不再有控制终端。

### SIGHUP

- 忽略SIGHUP信号并再次调用fork。该函数返回时，父进程实际上是上一次调用fork产生的子进程，它被终止掉，留下新的子进程继续运行。再次fork的目的是确保本守护进程将来即使打开了一个终端设备，也不会自动获得控制终端。当没有控制终端的一个会话头进程打开一个终端设备时（该设备不会是当前某个其他会话的控制终端），该设备自动成为这个会话头进程的控制终端。然而再次调用fork之后，可以确保新的子进程不再是一个会话头进程，从而不能再自动获得一个控制终端。这里必须忽略SIGHUP信号，因为当会话头进程（即首次fork产生的子进程）终止时，其会话中的所有进程（即再次fork产生的子进程）都收到SIGHUP信号。

### 为错误处理函数设置标识

- 如果守护进程发生错误，此时应该调用syslog，将错误输出到日志中。-

### 改变工作目录

- 把工作目录改到根目录，不过有些守护进程另有原因需改到其他某个目录。要是守护进程产生了某个core文件，该文件就存放在当前工作目录。改变工作目录的另一个理由是：守护进程可能是在某个任意的文件系统中启动，如果仍然在其中，那么该文件系统就将无法拆卸，除非使用潜在破坏性的强制措施。

### 关闭所有打开的描述符

- 关闭本守护进程从执行它的进程（通常是一个shell）继承而来的所有打开着的描述符。问题是怎样检测正在使用的最大描述符：没有现成的UNIX函数提供该值。检测当前进程能够打开的最大描述符数目自有办法，然而由于这个限制是无限的，这样监测也变得复杂起来。一个办法是干脆关闭前64个描述符，既使其中大部分没有打开。

[Solaris提供了closefrom函数，可用于解决守护进程的这个问题 ]

### 将stdin、stdout、stderr重定向到/dev/null

- 打开/dev/null作为本守护进程的标准输入、标准输出和标准错误输出、这一点保证这些常用描述符是打开的，针对它们的read系统调用总是返回0（EOF），write系统调用则有内核丢弃所写数据。打开这些描述符的理由是：守护进程调用的那些假设

