# 模板学习

### SFINAE原则（替换失败并非错误）

允许试图创建无效的类型，但不允许试图计算无效的表达式。

### 类型实参

1. 局部类和局部枚举不能作为模板的类型实参
2. 未命名的class类型或者未命名的枚举类型不能作为模板的类型实参（然而，通过typedef声明给出的未命名类和枚举是可以作为模板类型实参的）。

~~~c++
template<typename T>
class List;

typedef struct
{
    double x,y,z;
}Point;

typedef enum{red,green,blue}*ColorPtr;

int main(void)
{
    struct Association
    {
        int* p;
        int* q;
    };
    List<Association*> error1;//错误：模板实参中使用了局部类型
    List<ColorPtr> error2;//错误：模板实参中使用了未命名的类型，因为typedef定义的是*ColorPtr，并非ColorPtr。
    List<Point> ok;//正确：通过使用typedef定义的未命名类型
}
~~~



### 非类型实参

1.  某一个具有正确类型的非类型模板参数
2.  一个编译期整型常值（或枚举值）。这只有在参数类型和值的类型能够进行匹配，或者值的类型可以隐式地转换为参数类型（例如一个char值可以作为int参数的实参）的前提下，才是合法的。
3.  前面有单目运算符&（即取址）的外部变量或者函数的名称。对于函数或数组变量，&运算符可以省略。这类模板实参可以匹配指针类型的非类型参数
4.  一个指向成员的指针常量；换句话说，类似&C::m的表达式，其中C是一个class类型，m是一个非静态成员（成员变量或函数）。这类实参智能匹配类型为“成员指针”的非类型参数。

但是匹配“指针或者引用类型的参数”时，用户自定义的类型转换（单参数的构造函数和重载类型转换运算符）和由派生类到基类的类型转换，都不会被考虑。隐式类型转换的唯一应用是给实参加上const或volatile。

- 无效的非类型实参

1. 空指针常量
2. 浮点类型
3. 字符串

  另外单一数组元素的地址不可取。

  ~~~c++
  template<typename T, T nontype_param>
  class C;
  class X
  {
      public:
      int n;
      static bool b;
  };
  
  C<bool&,X::b>* c4;//静态类成员是可取的 变量（和函数）名称
  C<int X::*, &X::n>* c5;//指向成员的指针变量
  
  template<typename T>
  void templ_func();
  
  C<void(),&templ_func<double>>*c6;//函数模板实例同时也是函数
  
  class Base
  {
      public:
      int i;
  }base;
  
  class Derived:public Base
  {
  }derived_obj;
  
  C<Base*,&derived_obj>* err1;//错误：这里不会考虑派生类到基类的类型转换
  
  C<int&, base.i>* err2;//错误：域运算符（.）后面的变量不会被看成变量
  
  int a[10];
  C<int*,&a[0]>* err3;//错误：单一数组元素的地址并不是可取的
  ~~~

###  实参的等价性

1. 从成员函数模板产生的函数永远也不会改写一个虚函数（成员函数模板不能是一个虚函数）。
2. 从构造函数模板产生的构造函数一定不会是缺省的拷贝构造函数（类似，从赋值运算符模板产生的赋值运算符也一定不会是一个拷贝赋值运算符。但是，后面这种情况通常不会出现问题，因为与拷贝构造函数不同的是：赋值运算符永远也不会被隐式调用）。

### ODR原则（一处定义原则）

对于同一个程序，非内联函数只能在所有的文件中定义一次：对于类和内联函数，每个翻译单元最多只能定义一次；并且确保相同实体的所有定义都是相同的。

**翻译单元**：针对你给编译器提供的单个文件，让预处理器作用于该文件所获得的结果。预处理器会根据条件编译指示符（#if、#ifdef和友元）来去掉那些没有被选择的部分代码以及去掉注释，并且（递归地）插入#include文件和扩展宏。

各个翻译单元边界之间的连接是通过下面方法建立起来的：让相应的声明在两个翻译单元中具有外部链接（例如，全局函数的两处声明），或者在exported模板的实例化过程进行ADL查找时建立这种连接。

### 友元函数

友元函数可以是模板，如果友元函数名称后面没有紧跟一对尖括号，只有在下面两种情况下是合法的：

1. 如果名称是受限的（即包含一个形如双冒号的域运算符），那么该名称一定不是（也不能）引用一个模板实例。如果在友元声明的地方，还不可见所匹配 的非模板函数（即普通函数），那么这个友元声明就是函数的首次声明。于是，**该声明可以是定义**。
2. 如果名称是受限的（即前面有域运算符`::`），那么该名称必须引用一个在此之前声明的函数或者函数模板。在匹配的过程中，匹配的函数要优于匹配的函数模板。然而，这样的友元声明不能是定义。

另外，在模板内部定义的友元函数的类型定义中，必须包含类模板的模板参数（除非我们希望在一个特定的文件中禁止多于一个的实例创建，但这种用法很少）。由于函数的实体处于类定义的内部，所以这些函数是内联函数，因此在两个不同的翻译单元中可以生成相同的函数。