# Nim游戏

你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

示例:

~~~c++
输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
~~~

想法：使用动态规划的方法，假如石头数小于4，必定赢，如果石头数大于3后，在第i个石头处，如果前三个石头数只要有1个是不赢的，假如是第j（j<i）个石头，我输了，那么我只要令石头剩下i-j个，这i-j<4，所以我必赢。假如i-1，i-2和i-3都是我赢，那么现在我必输。因此有转移方程：

~~~mathematica
dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3])
~~~

程序如下：

~~~c++
bool canWinNim(int n) {
        if(n<4)
            return true;
        vector<bool> dp(n+1);
        dp[1]=true;
        dp[2]=true;
        dp[3]=true;
        for(int i=4;i<=n;++i)
        {
            dp[i]=!(dp[i-1]&& dp[i-2] && dp[i-3]);
        }
        return dp[n];
    }
~~~

非常不幸的是，当n极大时，最终超时。

查看网上的解法，该题是巴什博奕。即当石头数是4的整数倍时，无论你取任何数i的石头，别人只要去4-i的石头，别人必赢。否则你必赢。



