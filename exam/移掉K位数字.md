# 移掉K位数字

给定一个以字符串表示的非负整数 *num*，移除这个数中的 *k* 位数字，使得剩下的数字最小。

**注意:**

- *num* 的长度小于 10002 且 ≥ *k。*
- *num* 不会包含任何前导零。

**示例 1 :**

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

**示例 2 :**

```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

示例 **3 :**

```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

分析：

通过栈的方式，一位一位的入栈，如果当前栈里的尾元素大于待入栈的元素，将尾元素抛出，直到栈里的数据程递增。

如果现在抛掉的元素等于k，就一直入栈。

如果全部元素都入栈后，但是还需要抛掉更多的元素，由于现在栈里的元素是递增的，因此，将最后几位抛掉。这样就是最小的元素。



~~~c++
string removeKdigits(string num, int k) {
    if(num.size()<=k)
        return string("0");
    string temp;

    for(auto it:num)
    {
        while(!temp.empty() && temp.back()>it && k)
        {
            temp=temp.substr(0,temp.size()-1);
            --k;
        }
        temp+=it;
    }
    temp=temp.substr(0,temp.size()-k);
    int i=0;
    int len=temp.size();
    for(;i<len;++i)
    {
        if(temp[i]!='0')
            break;
    }
    temp=temp.substr(i);
    return temp==""?"0":temp;
}
~~~

最终写的时候，为了最后消掉最前面的0，所以没用栈，但是也可以先用栈，然后将栈里的元素逐渐加入到字符串中，将字符串尾后的0丢掉，然后翻转字符串即可。