# ZooKeeper分布式过程协同技术详解

## ZooKeeper的概念和基础

### 简介

ZooKeeper提供一组简单的API，使得开发人员可以实现通用的协作任务，包括选举主节点、管理组内成员、管理元数据等。ZooKeeper的服务组件运行在一组专用服务器之上，保证了高容错性和可扩展性。

决定使用ZooKeeper来设计应用时，最好将应用数据和协同数据独立开。

#### ZooKeeper的使命

可以在分布式系统中协作多个任务。一个协作任务是指一个包含多个进程的任务。这个任务可以是为了协作或者是为了管理竞争。协作意味着多个进程需要一同处理某些事情，一些进程采取某些行动使得其他进程可以继续工作。竞争指的是两个进程不能同时处理工作的情况。一个进程必须等待另一个进程。

协同并不总是采取像群首选举或者加锁等同步原语的形式。配置元数据也是一个进程通知其他进程需要做什么的一种常用方式。

ZooKeeper客户端API功能强大，包括：

-   保障强一致性、有序性和持久性
-   实现通用的同步原语的能力
-   在实际分布式系统中，并发往往导致不正确的行为。ZooKeeper提供了一种简单的并发处理机制



使用一个独立的协调组件有几个重要的好处：

-   可以独立地设计和实现该组件，这样独立的组件可以跨多个应用共享
-   系统架构师可以简化协作方面的工作
-   系统可以独立地运行和协作这些组件，独立这些组件，简化生产环境中解决实际问题的任务

ZooKeeper使用共享存储模型来实现应用间的协作和同步原语。对于共享存储本身，又需要在进程和存储间进行网络通信。网络通信的是分布式系统中并发设计的基础。

在真实的系统中，需要注意一下问题：

-   消息延迟：消息传输可能发生任意延迟。这种任意延迟可能会导致不可预期的后果。
-   处理器性能：操作系统的调度和超载也可能导致消息处理的任意延迟。
-   时钟偏移：使用时间概念的系统并不少见，时间可能会发生任意的偏移。因此，依赖处理器时钟也许会导致错误的决策。

#### 示例：主-从应用

一般在主-从应用架构中，主节点负责跟踪从节点状态和任务的有效性，并分配任务到从节点。要实现主-从模式的系统，必须解决如下三个关键问题：

-   主节点崩溃：如果主节点发送错误并失效，系统将无法分配新的任务或重新分配已失败的任务。
-   从节点崩溃：如果从节点崩溃，已分配的任务将无法完成。
-   通信故障：如果主节点和从节点之间无法进行信息交换时，从节点将无法得知新任务分配给它。

主节点失效时，需要有一个备份的主节点(backup master)。当主要主节点(primary master)崩溃时，备份主节点接管主要主节点的角色，进行故障转移。此时不是简单开始处理进入主节点的请求。新的主要主节点需要能够恢复到旧的主要主节点崩溃时的状态。对于主节点状态的可恢复性，不能依靠已经崩溃的主节点来获取这些信息，而需要从其他地方获取，即通过ZooKeeper来获取。

另外还有由于网络延迟、网络分区导致脑裂的情况。

**脑裂**：系统中两个或多个部分开始独立工作，导致整体行为不一致性。

需要找出一种处理主节点失效的情况，更重要的是需要避免发生脑裂的情况。

从节点失效：客户端向主节点提交任务后，主节点将任务派发到有效的从节点中。从节点接收到派发的任务，执行完这些任务后会向主节点报告执行状态，主节点下一步会将执行结果通知给客户端。

如果从节点崩溃，主节点需要具有检测从节点崩溃的能力。主节点必须能够检测到从节点的崩溃，并确认哪些从节点是否有效以便派发崩溃节点的任务。一个从节点崩溃时，可以执行了部分任务，也可能全部执行完，但没有报告结果。如果整个运算过程中发生了其他作用，还有必要执行某个恢复过程来清除之前的状态。

通信故障：如果一个从节点与主节点的网络连接断开，比如网络分区导致，重新分配一个任务可能会导致两个从节点执行相同的任务。如果一个任务允许多次执行，在进行任务再分配时可以不用验证第一个从节点是否完成了该任务。如果一个任务不允许，那么应用需要适应多个从节点执行相同任务的可能性。通信故障导致的另一个重要问题是对锁等同步原语的影响。

### 了解ZooKeeper

ZooKeeper暴露一部分调用方法组成的类似文件系统的API，帮助应用构建自己的原语。

通常使用recipes表示原语的实现。包括ZooKeeper操作和维护一个小型的数据节点，这些节点称为znode，采用类似于文件系统的层级树结构进行管理。

针对一个znode，没有数据常常表达了重要的信息。

#### API概述

znode节点可能含有数据，也可能没有。如果一个znode节点包含任何数据，那么数据存储为字节数组。ZooKeeper并不直接提供解析的支持。

ZooKeeper的API暴露了一下方法：

`create /path data`

​	创建一个名为`/path`的znode节点，并包含数据`data`

`delete /path`

​	删除名为`/path`的znode

`exists /path`

​	检查是否存在名为`/path`的节点

`setData /path data`

​	设置名为`/path`的znode的数据为data

`getData /path`

​	返回名为`/path`节点的数据信息

`getChildren /path`

​	返回`/path`节点的所有子节点列表

ZooKeeper不允许局部写入或读取znode节点的数据。

ZooKeeper客户端连接到ZooKeeper服务，通过API调用来建立会话`session`。

#### znode的不同类型

**持久节点和临时节点**

持久的znode只能通过调用`delete`来进行删除。

临时的znode节点在一下两种情况下会被删除：

-   当创建该节点的客户端的会话因超时或主动关闭而中止时
-   当某个客户端（不一定是创建者）主动删除该节点

当前不允许临时节点有子节点，但是以后可能会允许。

**有序节点**

一个有序节点被分配唯一一个单调递增的整数。当创建有序节点时，一个序号会被追加到路径之后。

因此znode分为：持久的，临时的，持久有序的和临时有序的。

#### 监视与通知

ZooKeeper采用基于通知`notification`的机制：客户端向ZooKeeper注册需要接收通知的znode，通过对znode设置监视点`watch`来接收通知。监视点是一个单次触发的操作，意即监视点会触发一个通知。为了接收多个通知，客户端必须在每次通知后设置一个新的监视点。

因为通知机制是单次触发的操作，所以在客户端接收一个znode变更操作并设置新的监视点时，znode节点也许发生了新的变化。但不会错过状态的变化。

**通知机制的重要保障：**对同一个znode的操作，先向客户端传送通知，然后再对该节点进行变更。

通知机制是一种异步回调的触发机制。具有如下特性：

-   一次触发
-   发往客户端：watches异步发往客户端，ZooKeeper提供一个顺序保证：在看到watch事件之前绝不会看到变化，这样不同的客户端看到的是一致性的顺序。ZooKeeper会保证次序：在收到观察事件之前，客户端不会看到已经为之设置观察的节点的变动。网络延迟或者其他因素可能会让不同的客户端在不同的时间收到观察时间和更新操作的返回码，但可以确保不同的客户端看到的事情都有一致的次序。
-   为数据设置watch：节点有不同的改动方式，ZooKeeper维护两个观察列表：数据观察和子节点观察。`getData`和`exists`设置数据观察，`getChildren`设置子节点观察。不同的返回数据有不同的观察。
-   时序性和一致性：watcher是在client连接到ZooKeeper服务端的本地维护。当一个client连接到新server，watch将会触发任何session事件，断开连接后不能接收到。当客户端重连，先前注册的watcher将会被重新注册并触发。



