# 初始Kafka

kafka扮演如下角色：

1.  消息系统：Kafka和传统的消息系统都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能，并且Kafka还提供了消息顺序性保障及回溯消费的功能。
2.  存储系统：Kafka把消息持久化到磁盘，有效降低数据丢失的分享。
3.  流式处理平台：Kafka为流式处理框架提供了可靠的数据来源，并且提供了完整的流式处理类库。

## 基本概念

Kafka体系架构包括若干Producer、若干Broker、若干Consumer以及一个Zookeeper集群。Producer将消息发送到Broker，Broker负责将收到的消息存储到磁盘中，Consumer负责从Broker订阅定消费消息。Zookeeper是Kafka用来负责集群元数据的管理、控制器的选举等操作。

Kafka的消息以主题为单位进行归类，生产者将消息发送到特定的主体，消费者负责订阅主题并进行消费。

主题是逻辑上的概念，可以细分为多个分区，一个分区只属于单个主题。同一个主题下的不同分区包含的消息时不同的，分区在存储层面可以看做一个可追加的日志文件。消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset是消息在分区中的唯一标识，Kafka通过它来保证消息在分区内的顺序性，不过offset不跨越分区，即Kafka保证的是分区有序而不是主题有序。

Kafka为分区引入了多副本(Replica)机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息，副本之间是“一主多从”的关系，leader副本负责处理读写请求，follower副本只负责与leader服务的消息同步。副本出于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。

Kafka消费端也具备一定的容灾能力，Consumer使用pull模式从服务端拉取消息，并且保证消费的具体位置，当消费者宕机后恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费。

分区中的所有副本统称为AR(Assigned Replicas)。所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR(In-Sync Replicas)，ISR集合是AR集合中的一个子集。消息会先发送到leader副本，然后follower副本才能从leader服务中拉取消息进行同步。同步期间follower副本相对于leader副本而言有一定程度的滞后。“一定程度的滞后”是指可忍受的滞后范围，可以配置。与leader副本同步滞后过多的副本（不包括leader副本）组成OSR(Out-of-Sync Replicas)，因此AR=ISR+OSR。

leader副本负责维护和跟踪ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果OSR集合中有follower副本“追上”了leader副本，那么leader副本会把它从OSR集合中转移到ISR集合。默认情况下，leader副本发生故障时，只有ISR集合中的副本才有资格被选举为新的leader。（这个选举可以配置）

ISR与HW和LEO有紧密的关系。LEO表示当前日志分拣中下一条待写入消息的offset，如果最新的消息offset为9，那么LEO就是10。分区ISR集合中的每个副本都会维护自身的LEO，ISR集合中最小的LEO为分区的HW，消费者只能消费HW之前的消息。

Kafka的复制机制不是完全的同步复制，也不是单纯的异步复制。

# 生产者

生产者是负责向Kafka发送消息的应用程序。发送消息时，会携带如下属性：topic和partition分别表示消息要发往的主题和分区号。headers字段是消息的他头部，用来设定一些与应用无关的消息。key用来指定消息的键，不仅是消息的附加信息，也可以用来计算分区号进而让消息发往特定的分区。同一个key会被划分到同一个分区中，并且有key的消息支持日志压缩的功能。value指消息体，一般不为空，如果为空表示特定的消息-墓碑消息。timestamp表示消息的时间戳，有CreateTime和LogAppendTime两种类型，前者表示消息创建的时间，后者表示消息追加到日志文件的时间。

### 分区器

消息在通过send发往broker的过程中，需要经过拦截器、序列化器、分区器等才能真正发往broker。如果消息中指定了partition的值，就不需要分区器。否则会根据key计算partition的值。分区器的作用是位消息分配分区。

如果key不为null，计算得到的分区号是所有分区中的任意一个；如果key为null，计算得到的分区号仅为可用分区中的任意一个。

一旦改变了分区，不保证key和分区之间的映射关系。

### 拦截器

拦截器分为生产者拦截器和消费者拦截器。

生产者拦截器可以过滤不符合要求的消息、修改消息的内容，也可以在发送回调逻辑前做定制化的需求，比如统计。

## 原理分析

### 生产者参数

acks：用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。设计消息的可靠性和吞吐量之间的权衡。

1.  acks=1：默认值，生产者发送消息之后，只要分区的leader副本成功写入消息，就会收到来自服务端的成功响应。
2.  acks=0：发送消息之后不需要等待任务服务端的响应，可以达到最大的吞吐量。
3.  acks=-1或all：生产者发送消息之后，需要等待ISR中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应。

# 消费者

## 消费者和消费组

消费者负责订阅Kafka中的主题，并且从订阅的主题上拉取消息。在Kafka的消费理念中还有一层消费组的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递到订阅它的每个消费组中的一个消费者。

不同消费组之间互不影响。例如某主题有4个分区，有两个消费组A和B都订阅这个主题，消费组A中有四个消费者，消费组B中有两个消费者，最后分配结果是消费组A中每一个消费者分配到1个分区，消费组B中每一个消费者分配到2个分区。

可以通过增加/减少消费者的个数来提高/降低整体的消费能力。如果消费者个数大于分区个数的情况下，会有消费者分配不到任何分区。

消息投递模式：

-   点对点模式：基于队列的，消息生产者发送消息到队列，消费者从队列中接收消息
-   发布/订阅模式：定义了如何向一个内容节点（主题）发布和订阅消息。主题可被认为是消息传递的中介，消息发布者将消息发布到某个主题，消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。

Kafka同时支持两种消息投递模式：

-   如果所有消费者都隶属于同一个消费组，那么所有消息都会被均衡地投递给每一个消费者，每条消息只会被一个消费者处理，相当于点对点模式的应用
-   如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者。即每条消息都会被所有的消费者处理，相当于订阅/发布模式的应用。

消费组是一个逻辑上的概念，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称。

一个正常的消费逻辑需要具备以下几个步骤：

-   配置消费者客户端参数及创建相应的消费者实例
-   订阅主题
-   拉取消息并消费
-   提交消息位移
-   关闭消费者实例

## 再均衡

再均衡指分区的所属权从一个消费者转移到另一个消费者的行为，为消费组具备高可用和伸缩性提供保障，可以既方便又安全地删除消费组内的消费者和往消费组内添加消费者。在再均衡发生期间，消费组内的消费者无法读取消息。当一个分区被重新分配给另一个消费者时，消费者当前的状态会丢失，可能导致重复消费。

# 主题与分区

主题为消息的归类，可以细分为一个或多个分区，分区不仅为kafka提供了可伸缩性，水平扩展的能力，还通过多副本机制为kafka提供数据冗余以提高数据的可靠性。

分区可以有一至多个副本，每个副本对应一个日志文件，每个日志文件对应一至多个日志分段，每个日志分段可以细分为索引文件、日志存储文件和快照文件等。

## 创建主题

创建主题时尽量保证每个broker中都拥有所有分区的一个副本。

创建主题时不能出现相同的主题名。

注：主题的命名不推荐使用双下划线开头。双下划綫开头的主体一般看做kafka的内部主题。

### 分区副本的分配

生产者的分区分配是指为每条消息指定其所要发往的分区，消费者总的分区分配是指为消费者指定其可以消费消息的分区。

### 修改主题

当主题创建成功后，可以增加主题的分区数。增加分区后，会影响既定消息的顺序，并且会影响key发送的分区。目前不支持减少分区数。因为减少分区后，删除的分区中的消息如何处理是一个很大的问题。

删除题是一个不可逆的操作。一旦删除之后，与其相关的所有消息数据会被全部删除。