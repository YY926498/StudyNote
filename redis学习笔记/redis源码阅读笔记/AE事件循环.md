# AE事件循环

由于不同的系统平台提供的I/O多路复用的函数不一样，redis采用预处理的方式，选择对应I/O多路复用函数。

主要有：evport、epoll、kqueue和select四种方式。

优先级是evport->epoll->kqueue->select。

分析epoll：

首先调用epoll_create，创建一个epoll文件描述符

将文件描述符及对应的工作模式注册到epoll中

调用epoll_wait，等待可用的文件描述符，然后调用对应的处理函数



select、poll和epoll的分析：

select传入的参数：

-   最大的文件描述符加1，代表需要检查的文件描述符个数
-   readset：用来检查可读性的一组文件描述符集合，类型为fd_set指针，最大为1024
-   writeset：用来检查可写性的一组文件描述符集合
-   exceptset：用来检查是否有异常条件出现的文件描述字（错误不包括在异常条件之内）
-   timeout：超时时间

poll传入的参数：

-   fds：pollfd结构指针，指向多个事件，需要关心的同一个文件描述符的多个事件放在同一个结构体中
-   nfds：fds指针指向的数组大小
-   timeout：超时时间

epoll：

分为三个主要函数：

epoll_create、epoll_ctl和epoll_wait函数。

首先epoll_create创建epoll文件描述符，然后用epoll_ctl注册或者修改文件描述符需要关注的事件，然后调用epoll_wait得到触发对应事件的文件描述符。

对比：

select：每次调用前需要将对应的文件描述符拷贝到相应fd_set中，并且fd_set有限制，一般是1024，可以通过修改内核源码，扩大限制。然后每次都需要对文件描述符遍历一次，效率低下，但是对于少数连接，并且活跃度高的情形，使用该函数比较简单，相比其他两种不会相差太多

poll：基本与select相似，但是对每个文件描述符，用一个结构体pollfd来表示文件描述符应该关心的事件，并且最大可支持进程打开的文件描述符上限，一般是65535.

epoll：拆分成三个函数，使用起来更方便，增加、删除或修改文件描述符对应事件只需要调用epoll_ctl函数即可。数据拷贝少，在调用epoll_ctl函数，将文件描述符添加到内核中，后续不需要重新添加，采用回调函数的方法，将就绪的文件描述符结构加入到就绪队列中。

epoll内部会维护一个红黑树，每次注册文件描述符时，将文件描述符添加到红黑树中，然后发生对应的事件后，将文件描述符拷贝到就绪列表中，用户调用epoll_wait后，将就绪列表中的文件描述符拷贝到用户所给的数组中。

epoll支持水平触发和边缘触发两种工作方式。

水平触发机制同select、poll一样，针对可读事件，只要缓冲区有数据就会一直返回，针对可写事件，只要缓冲区未满就会一直返回。

边缘触发：仅针对非阻塞IO：针对可读事件：必须有新数据到来才会返回，针对可写事件，必须缓冲区数据量减少才会触发。仅针对非阻塞IO是因为阻塞IO采用这种方式，需要不断读写IO，有可能造成阻塞，因此必须是非阻塞IO。

两种模式的效率需要具体情形具体分析。

在读事件下，水平模式的含义是：监控并探测socket是否有数据可读，跟epoll_wait原本的含义相同，边缘模式的含义是：监控并探测socket是否有新的数据可读

另外对于边缘模式下的socket，需要考虑“饿死”的情形。当一个socket频繁发送数据过来，由于边缘模式针对每个socket都是采用不断轮询的方式读取数据，如果一直读取同一个socket，那么其他socket的数据得不到处理，就会”饿死“。

epoll惊群问题

多线程或者多进程情形下，为了提高程序的稳定性，让多个线程或者多个进程同时在epoll_wait监听同一个socket描述符，当一个新的事件触发时，操作系统不知道选择哪个线程或进程处理此事件，会同时唤醒多个线程或者进程，但是只有一个进程或者线程能够成功处理事件，其他的都会失败，且errno错误码为EAGAIN。这种现象称为惊群效应。

多线程下：避免将同一个socket放到多个线程中调用

如果多线程中每一个线程都对同一个epoll文件描述符查询，一个socket加入到多个线程中，一个线程正在读取数据，突然又有新数据到来，此时可能会唤醒另一个线程处理数据，一个是避免这样做，另一个是考虑加入EPOLLONESHOT选项。EPOLLONESHOT是每次触发事件之后，将事件注册从fd上清除，不会再次被追踪到，下次需要用epoll_ctl的EPOLL_CTL_MOD来手动加上。