redis分布式锁

需要具备以下3个特性可以实现一个最低保障的分布式锁

1. 安全属性：独享（互斥）。在任意时刻，只有一个客户端持有锁
2. 活性A：无死锁。即便持有锁的客户端崩溃或者网络被分裂，锁仍然可以被获取
3. 活性B：容错。只要大部分Redis节点都活着，客户端就可以获取和释放锁

基于故障转移的实现：在Redis中创建一个key，这个key有一个失效时间，保证锁最终会被自动释放掉（对应特性2）。当客户端释放资源（解锁）的时候，会删除掉这个key。

这种场景存在明显的竟态：

1. 客户端A从master获取到锁
2. 在master将锁同步到slave之前，master宕机
3. slave节点被晋级为master节点
4. 客户端B取得了同一个资源被客户端A已经获取到的另一个锁。**安全失效**

Redlock算法

在Redis的分布式环境中，假设有N个Redis master。这些节点完全互相独立，不存在主从复制和其他集群协调机制。

1. 获取当前Unix时间，以毫秒为单位
2. 依次尝试从N个实例，使用相同的key和随机值获取锁。在设置锁时，客户端设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。避免服务器端Redis已经挂掉的情况下，客户端还在等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另一个Redis实例
3. 客户端使用当前时间减去开始获取锁时间就能得到获取锁使用的时间。当且仅当从大多数（超过N/2个节点）的Redis节点都获取到锁，并且使用时间小于锁的失效时间，锁才算获取成功
4. 如果取得了锁，key的真正有效时间等于有效时间减去获取锁锁使用的时间
5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取得锁或者取锁时间已经超过了有效时间），客户端应该在所有Redis实例上进行解锁

这种算法是基于虽然多个进程之间没有时钟同步，但每个进程都以相同的时钟频率前进，时间差相对于失效时间来说几乎可以忽略不计。只有在锁的有效时间范围内客户端能够做完它的工作，锁的安全性才能得到保证。

**失败时重试**

当客户端无法获取到锁时，应该在一个随机延迟后重试，防止多个客户端在同时抢夺同一资源的锁。同样，客户端取得大部分Redis实例锁锁花费的时间越短，脑裂出现的概率就会越低。理想情况下，客户端应该同时向所有redis发送SET命令。

**活性争议**

系统的活性安全基于三个主要特性：

1. 锁的自动释放：最终锁可以再次被使用
2. 客户端通常会将没有获取到的锁删除，或者锁被取到后，使用完后，客户端主动（提前）释放锁，而不是等到锁失效，另外的客户端才能取到锁
3. 当客户端重试获取锁时，需要等待一段时间，这个时间必须大于从大多数Redis实例成功获取使用的时间，以最大限度地避免脑裂。

DDIA作者指出了Redlock的缺点：

Redlock是基于下列假设：

- 有界的网络延迟：可以保证数据包始终在一定的最大延迟内到达
- 有限的过程暂停：由于操作系统导致进程交换
- 有限的时钟错误：redis获取时间使用的是gettimeofday函数，可以被外界修改，不是单调递增

Redlock过于繁重且昂贵，而且也不够安全。



