# redis分布式锁

一般来说，在对数据进行“加锁”时，程序首先需要通过获取锁来得到对数据进行排他性访问的能力，然后才能对数据执行一系列操作，最后还要将锁释放给其他程序。

在redis中使用`WATCH`命令来代替对数据进行加锁，因为`WATCH`只会在其他客户端抢先修改了的情况下通知执行了这个命令的客户端，而不会阻止其他客户端对数据进行修改，所以这个命令被称为乐观锁。

分布式锁也有类似“首先获取锁，然后执行操作，最后释放锁”动作。但这种锁不是给同一个进程的多个线程使用，也不是给同一台机器上的多个进程使用，而是由不同的机器上的不同redis客户端进行获取和释放的。

使用redis构建锁，其中一个原因和范围有关：为了对redis存储的数据进行排他性访问，客户端需要访问一个锁，这个锁必须定义在一个可以让所有客户端都看得见的范围之内，而这个范围就是redis本身，因此需要把锁构建在redis里面。另一方面，虽然redis提供的`SETEX`命令确实具有基本的加锁功能，但它的功能并不完整，并且也不具备分布式锁常见的一些高级特性，所以需要手动构建分布式锁。

使用`WATCH`、`MULTI`和`EXEC`组成的事务并不具有可扩展性，当负载不断增加时，重试次数将不断提高。



### 使用redis实现的锁可能出现的问题

- 持有锁的进程因为操作时间过长而导致锁被自动释放，但进程本身并不知晓这一点，甚至还可能会错误地释放掉了其他进程持有的锁
- 一个持有锁并打算执行长时间操作的进程已经崩溃，但其他想要获取锁的进程不知道哪个进程持有着锁，也无法检测出持有锁的进程已经崩溃，只能白白地浪费时间等待持有锁被释放
- 在一个进程持有的锁过期之后，其他多个进程同时尝试获取锁，并且都获得了锁
- 上面提到的第一种情况和第三种情况同时出现，导致多个进程获得了锁，而每个进程都以为自己是唯一一个获得了锁的进程。



### 使用redis实现简易锁

`SETNX`命令只会在键不存在的情况下为键设置值。

- 调用`SETNX`设置一个不存在的键，并且用一个UUID作为这个键的键值，防止该键被其他客户端修改
- 释放时，调用`WATCH`，然后获取键的键值，判断是否与之前的UUID是否相等，如果有其他进程修改了锁，就需要进行相应的处理。

### 细粒度锁

可以考虑将锁的范围减少，以此提高速度，避免等待。

### 带有超时限制特性的锁

通过调用`EXPIRE`命令来为锁设置过期时间，使得redis可以自动删除超时的锁。为了确保锁在客户端已经崩溃(客户端在执行介于`SETNX`和`EXPIRE`之间的时候崩溃是最糟糕的)的情况下仍然能够自动被释放，客户端会在尝试获取锁失败之后，检查锁的超时时间，并为未设置超时时间的锁设置超时时间。因此锁总是带有超时时间，并最终因为超时而被自动释放，使得其他客户端可以继续尝试获取已被释放的锁。

因为多个客户端在同一时间内设置的超时时间大致相同，因此不需要担心。

