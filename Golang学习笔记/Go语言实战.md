# Go语言实战

1.  如果通过接口类型的值调用方法，与普通类型的规则有很大不同。使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。

2.  在创建切片时，可以使用第三个索引选项。第三个索引选项可以用来控制新切片的容量。其目的不是要增加新容量，而是要限制容量。允许限制新切片的容量为底层数组提供了一定的保护，可以更好地控制追加操作。

~~~go
source := make([]string,5,5)
slice := source(2,3,4)
~~~

这个切片操作执行后，新切片里从底层数组引用了1个元素，容量是2个元素。如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误。如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个`append`操作创建新的底层数组，与原有的底层数组分离，就可以安全地进行后续操作。

内置的`append`是一个可变参数的函数。这意味着可以在一次调用里传递多个追加的值。如果使用`...`运算符，可以将一个切片的所有元素追加到另一个切片里。

`range`创建了每个元素的副本，而不是直接返回对该元素的引用。因为迭代返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以可能地址是相同的。

Go语言里的`append`函数处理多维切片时追加的方式很简明：先增长切片，再将新的整型切片赋值给外层切片的第一个元素。当操作完成后，会为新的整型切片分配新的底层数组，然后将切片复制给外层切片的索引为0的元素。

### 接口的方法集

方法集定义了接口的接受规则。方法集规则为：

| Values |    方法接收者    |
| :----: | :--------------: |
|   T    |      （t T)      |
|   *T   | (t T) and (t *T) |

描述中说到，T类型的值的方法集只包含值接受者声明的方法。而指向T类型的指针的方法集既包含值接受者声明的方法，也包含指针接收者声明的方法。

这种限制是因为编译器并不总是能自动获得一个值得地址，如图所示：

~~~go
package main
import "fmt"
type duration int
func (d *duration) pretty() string{
    return fmt.Sprintf("Duration: %d",*d)
}
func main(){
    duration(42).pretty()//不能通过指针调用duration(42)的方法
}
~~~

上述代码试图获取duration类型的值的地址，但是获取不到。因为不是总能获得一个值得地址，所以值得方法集中只包括了使用值接受者实现的方法。