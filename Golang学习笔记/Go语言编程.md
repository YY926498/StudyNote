# Go语言编程

## 入门

### hello,world

Go语言的代码通过包`package`组织，包类似于库或者模块。一个包由单个目录下的一个或多个`.go`源代码文件组成，目录定义包的作用。每个源文件都以一条`package`声明语句开始，表示该文件属于哪个包，紧跟着一系列导入`import`的包，之后是存储在这个文件里的程序语句。

`main`包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在`main`里的`main`函数是整个程序执行时的入口。

`import`声明必须跟在文件的`package`声明之后。随后，则是组成程序的函数、变量、常亮、类型的声明语句（分别由关键字`func`、`var`、`const`和`type`定义）。

一个函数的声明由`func`关键字、函数名、参数列表、返回值列表以及包含在大括号里的函数体组成。

### 命令行参数

`os`包以跨平台的方式，可通过`os`包的`Args`变量获取。`os.Args`变量是一个字符串的切片。用`s[i]`访问单个元素，用`s[m:n]`获取子序列，区间索引时，Go也采用左闭右开形式，`s[m:n]`包含n-m个元素。

`os.Args`的第一个元素`os.Args[0]`是命令本身的名字，其他元素则是程序启动时传给它的参数。要获取其他所有的命令行参数可以用`os.Args[1:len(os.Args)]`或者`os.Args[1:]`。

如果程序里需要导入多个包，可以每个包写一份`import`声明，也可以用`()`括起来，比如：

~~~go
import(
    "fmt"
    "os"
)
~~~

注释语句以`//`开头。按照惯例，在每个包的包声明前添加注释，对于`main package`，注释包含一句或几句话，从整体角度对程序做个描述。

`var`声明定义变量。变量会在声明时直接初始化。如果变量没有显示初始化，则被隐式地初始化成空字符串。

`:=`是短变量声明的一部分，这是定义一个或多个变量并根据他们的初始值为这些变量赋予适当类型的语句。

`++`和`--`是语句，不像C系的其他语言是表达式。所以`j=i++`非法，而且`++`和`–-`都只能放在变量名后面，因此`–-i`非法

Go语句只有`for`循环这一种循环语句。`for`循环有多种形式，其中一种如下：

~~~go
for initialization; condition; post{
    //zero or more statements
}
~~~

`for`循环的三个部分不需括号包围。大括号强制要求，左大括号必须和`post`语句在同一行。

`initialization`语句是可选的，在循环开始前执行。`initlization`如果存在，必须是一条简单语句，即短变量声明、自增语句、赋值语句或函数调用。`condition`是一个布尔表达式，其值在每次循环迭代开始时计算。`post`语句在循环体执行结束后执行，之后再次对`condition`求值。

`for`循环的这三个部分每个都可以被省略，如果省略`initlization`和`post`，分号也可以被省略：

~~~go
//a traditional "while" loop
for condition{
    //...
}
~~~

如果连`condition`也省略，可以这样

~~~go
//a traditional infinite loop
for{
    //...
}
~~~

这样就会变成无限循环。可以采用`break`或者`return`语句。

`for`循环的另一种形式，在某种数据类型的区间上遍历

~~~go
for index, arg := range os.Args[1:]{
    fmt.Println("下标：",index,"\t",arg)
}
~~~

每次循环迭代，`range`产生一对值：索引以及该索引处的元素值。由于Go语言不允许使用无用的局部变量，这样会导致编译错误。因此如果不想要用索引，可以采用空标识符，即`__`（下划线）。空标识符可用于任何语法需要变量名但程序逻辑不需要的时候，类似于C++的`std::ignore`。

声明变量的形式有：

~~~go
s := ""
var s string
var s = ""
var s string = ""
~~~
第一种是短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为“”。第三种形式用的少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式的某个，初始值重要地话就显式地指定变量的类型，否则使用隐式初始化。

`+=`连接字符串，产生新字符串，并把它赋值给`s`。`s`原来的内容不再使用，将在适当时机对它进行垃圾回收。如果连接设计的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用`strings`包的`join`函数：

~~~go
func main(){
    fmt.Println(strings.Join(os.Args[1:]," "))
}
~~~

另外，还可以直接输出切片：

~~~go
fmt.Println(os.Args[1:])
~~~

最后每个元素都放在一对方括号里。

### 查找重复的行

`if`语句类似`for`循环一样，两边不加括号。

~~~go
if condition{
    //...
}
~~~

`map`存储了键/值的集合，对集合元素，提供了常数时间的存，取或测试操作。键可以是任意类型，只要其键的值能用`==`运算符比较，值可以是任意类型。`map[string]int`定义的键是`string`，值是`int`。内建函数`make`具有很强的作用，例如：

~~~go
counts := make(map[string]int)
~~~

就是创建一个键是string，值是int的空map。Go中的map是哈希表，类似C++的unordered_map。同样，对map中不存在的元素使用`[]`，将对其赋其值类型的零值，对于`int`就是0。

`bufio`包使处理输入和输出方便又高效。`Scanner`类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。

使用短变量声明创建`bufio.Scanner`类型的变量`input`。

~~~go
input := bufio.NewScanner(os.Stdin)
~~~

该变量从程序的标准输入中读取内容。每次调用`input.Scan()`,即读取下一行，并移除行末的换行符；读取的内容可以调用`input.Text()`得到。`Scan`函数在读到一行时返回`true`，不再有返回时，返回`false`。

`fmt.Printf`函数类似于C语言的`printf`，可以产生格式化输出。该函数的首个参数是个格式化字符串，指定后续参数被如何格式化。每个参数的格式取决于“转换字符”，形式为百分号后跟一个字母。Go程序员称之为动词。

|    %d    |                 十进制整数                 |
| :------: | :----------------------------------------: |
| %x,%o,%b |        十六进制，八进制，二进制整数        |
| %f,%g,%e |                   浮点数                   |
|    %t    |             布尔：true或false              |
|    %c    |            字符（unicode码点）             |
|    %s    |                   字符串                   |
|    %q    | 带双引号的字符串“abc”或者带单引号的字符‘c’ |
|    %v    |               变量的自然形式               |
|    %T    |                 变量的类型                 |
|    %%    |             字面上的百分号标志             |

默认情况下，`Printf`不会换行。按照惯例，以字母`f`结尾的格式化函数，如`log.Printf`和`fmt.Errorf`都采用`fmt.Printf`的格式化准则。而已`ln`结尾的格式化函数，则遵循`Println`的方式，以跟`%v`差不多的方式格式化参数，并在最后添加一个换行符。后缀`f`指`format`，`ln`指`line`。

`os.Open`函数返回两个值。第一个值是被打开的文件（`*os.File`），其后被`Scanner`读取。返回的第二个值是内置`error`类型的值。如果`err`等于内置值`nil`，那么文件被成功打开。读取文件，直到文件结束，然后调用`Close`关闭该文件，并释放占用的所有资源。相反，如果`err`的值不是`nil`，说明文件打开失败，这种情况下，错误值描述了所遇到的问题。

函数和包级别的变量可以任意顺序声明，并不影响其被调用。

`make`函数可以创建数据结构，比如`make(map[string]int)`创建一个`map`的引用。`map`作为参数传递给某函数时，该函数接受这个引用的一份拷贝，被调用函数对`map`底层数据结构的任何修改，调用者函数都可以通过持有的`map`的引用看到。类似于C++的引用传递。

`ReadFile`函数返回一个字节切片，必须把它切换为`string`，才能用`strings.Split`分割。

### GIF动画

常量是指在程序编译后始终都不会变化的值，一般出现在包级别的。但也可以声明定义在函数体内部，那么这种常量就只能在函数体内用。目前常量声明的值必须是一个数字值/字符串或者一个固定的boolean值。

`[]color.Color{...}`和`gif.GIF{...}`这两个表达式是复合声明。这是实例化Go语言里的符合类型的一种写法。前者生成的是一个`slice`切片，后者生成的是一个`struct`结构体。如下：

~~~go
//gif
type GIF struct {
	Image []*image.Paletted 
	Delay []int         
	LoopCount int
	Disposal []byte
	Config image.Config
	BackgroundIndex byte
}

anim := gif.GIF{LoopCount : 1}
~~~

上述是实例化一个GIF结构体，并且将其中的`LoopCount`成员初始化为1，其他成员会被设置各自类型默认的零值。

### 获取URL

主要使用`net/http`和`io/ioutil`包。其中`http.Get`函数是创建`HTTP`请求的函数，如果获取过程没有出错，那么就会在返回的结果中得到访问的请求结果。返回的Response指针的`Body`字段包括一个可读的服务器响应流。`ioutil.ReadAll`函数从`response`中读取到全部内容，将其结果保存到一个变量中。`response.Body.Close`函数关闭`response`的`Body`流，防止资源泄露。

### 并发获取多个URL

`goroutine`是一种函数的并发执行方式，而`channel`是用来在`goroutine`之间进行参数传递。`main`函数本身也运行在一个`goroutine`中，而`go function`则表示创建一个新的`goroutine`，并在这个新的`goroutine`中执行这个函数。

使用`make`函数创建一个传递`string`类型参数的`channel`：

~~~go
ch := make(chan string)
~~~

`ioutil.Discard`输出流相当于一个垃圾桶。使用`io.Copy`可将一个字节数组拷贝到一个输出流，并返回长度。

当一个`goroutine`尝试在一个`channel`上做`send`或者`receive`操作时，这个`goroutine`会阻塞在调用处，直到另一个`goroutine`从这个`channel`里接收或者写入值，这样两个`goroutine`才会继续执行`channel`操作之后的逻辑。

~~~go
ch := make(chan string)
ch <- string("nihao")//将数据写到channel
fmt.Println(<-ch)//从channel中读取数据
~~~

### Web服务

主要使用

~~~go
http.HandleFunc("/",func(w http.ResponseWriter, r *http.Request){
	//...
})
~~~

### 本章总结

`switch`：

~~~go
switch coinflip () {
    case "heads":
    	heads++
    case "tails":
    	tails++
    default:
    fmt.Println("landed on edge!")
}
~~~

Go语言不需要显式地在每一个`case`后写`break`，语言默认执行完`case`后的逻辑语句会自动退出。如果想相邻的几个`case`都执行同一逻辑，需要显式地写上一个`fallthrough`语句来覆盖这种默认行为。

另外Go语言的`switch`可以不带对象（`switch`不带操作对象时，默认用`true`值代替，然后将每个`case`的表达式和true值进行比较；可以直接罗列多种条件，像其他语言的`if else`一样，如下：

~~~go
func Signum(x int)int {
    switch {
        case x>0:
        	return +1
        default:
        	return 0
        case x<0:
        	return -1
    }
}
~~~

这种叫`无tag switch`；这和`switch true`等价。

类似于`for`和`if`控制语句一样，`switch`也可以紧跟一个简短的变量声明，一个自增表达式/赋值语句，或者一个函数调用。

**命名类型**：类型声明可以很方便地给一个特殊类型一个名字。因为`struct`类型声明非常长，可以给`struct`取一个名字。例如：

~~~go
type Point struct {
    X, Y int
}

var p Point
~~~

**指针**：Go语言提供了指针。指针时一种直接存储了变量的内存地址的数据类型。Go语言的指针没有C语言这么强。指针是可见的内存地址，`&`操作符可以返回一个变量的内存地址，并且`*`操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像C语言里可以对指针进行加或减操作。

**方法和接口**：方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。

**包(package)**：Go语言提供了很多包，并且这些包是可以扩展的。借助`godoc`工具可以直接在本地命令行阅读标准库的文档：

~~~go
go doc http.ListenAndServe
---------------------------------------------------------------------
package http // import "net/http"

func ListenAndServe(addr string, handler Handler) error
    ListenAndServe listens on the TCP network address addr and then calls Serve
    with handler to handle requests on incoming connections. Accepted
    connections are configured to enable TCP keep-alives.

    The handler is typically nil, in which case the DefaultServeMux is used.

    ListenAndServe always returns a non-nil error.
~~~

**注释**：在源文件开头写注释和在每个函数前写一个说明函数行为的注释是一个好习惯，可以被`godoc`这样的工具检测到。并且在执行命令时显示这些注释。

多行注释可以用`/*...*/`来包裹。

## 程序结构

### 命名

Go语言中的函数名，变量名，常量名，类型名，语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母，数字或下划线。大写字母和小写字母是不同的。

**关键字**：

~~~go
break		default			func	interface	select
case		defer			go		map			struct
chan		else			goto	package		switch
const		fallthrough		if		range		type
continue	for				import	return		var
~~~

预定义名字：

~~~go
内建常量：true	false	iota	nil

内建类型：int	int8	int16	int32	int64
		uint	uint8	uint16	uint32	uint64	uintptr
		float32	float64	complex128	complex64
		bool	byte	string	error

内建函数：make	len	cap	new	append	copy	close	delete
		complex	real	imag
		panic	recover
~~~

这些内部预定义的名字不是关键字，可以重新定义，但是要避免过度定义引起混乱。

如果一个名字是在函数内部定义，那么它就在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（必须是在函数外部定义的包级别的名字，包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如`fmt`包的`Printf`函数就是导出的，可以在`fmt`包外部访问。包本身的名字一般是用小写字母。

名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。通常来说，如果一个名字的作用域比较大，声明周期比较长，那么用长的名字就会更有意义。

Go语言推荐使用驼峰式命名，当名字由几个单词组成，优先使用大小写分割，而不是优先使用下划线分割。但是对于缩略词，采用全部大写的形式，例如：`ASCII`或者`HTML`。

### 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：`var`，`const`，`type`和`func`。分别对应变量，常量，类型和函数实体对象的声明。

在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。

一个函数的声明由一个函数名字，参数列表（由函数的调用者提供参数变量的具体值），一个可选的返回值列表和包含函数体定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，一次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。

### 变量

`var`声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

~~~go
var 变量名字  类型 = 表达式
~~~

其中`类型`或`= 表达式`两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。数值类型变量对应的零值是0，布尔类型的变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括`slice`，指针，`map`，`chan`和函数）变量对应的零值是`nil`。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。 

在一个声明语句中可以同时声明一组变量，或用一组初始化声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：

~~~go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
~~~

如果要同时定义多个类型的变量，同时没有初始化表达式，可以采用如下形式：

~~~go
var (
	i int
    f float
    s string
)
~~~

初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。

一组变量也可以通过调用一个函数，由函数返回的多个值进行初始化

~~~go
var f, err = os.Open(name)
~~~

**简短变量声明**

在函数内部，可以使用简短变量声明语句的形式用于声明或初始化局部变量。以`名字 := 表达式`形式声明变量，变量的类型根据表达式来自动推导。

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。`var`形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后被重新赋值而初始值无关紧要的地方。

和`var`形式声明语句一样，简短变量声明语句可以用来声明和初始化一组变量：

~~~go
i, j := 0,1
~~~

但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如`for`语句的循环初始化语句部分。

`:=`是一个变量声明语句，而`=`是一个变量赋值操作。不要混肴多个变量的声明和元组的多重赋值，后者是将右边各个表达式的值赋值给左边对应位置的各个变量：

~~~go
i, j = j, i//交换i和j的值
~~~

和普通`var`形式的变量声明语句一样，简短变量声明语句可以用函数的返回值来声明和初始化变量：

~~~go
f, err := os.Open(name)
if err != nil {
    return err
}
f.Close()
~~~

注：简短变量声明的坐边变量可能并不是全部刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短的变量声明语句对这些已经声明过的变量就只有赋值行为了。即简短变量声明至少有一个新的变量。

~~~go
//success
in, err := os.Open(infile)
//...
out, err := os.Open(outfile)

//fail
f, err := os.Open(infile)
//...
f, err := os.Open(outfile)
~~~

解决的方法是第二个简短变量声明改用普通的多重赋值语句。简短声明变量语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

**指针**

~~~go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
~~~

与C语言类似。 任何类型的指针的零值都是nil。如果p指向某个有效变量，那么`p != nil`测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等 。

在Go语言中，返回函数局部变量的地址是安全的。即：

~~~go
var p = f()
func f()*int{
    v := 1
    return &v
}
~~~

每次调用f函数返回的结果不同：

~~~go
fmt.Println(f() == f())//false
~~~

因此指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。

指针会创建别名，其他引用类型也会创建别名，例如`slice`，`map`和`chan`，甚至结构体，数组和接口等都会创建所引用变量的别名。

指针是实现标准库中`flag`包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。

~~~go
var n = flag.Bool("n",false,"omit trailing newline")
~~~

比如：`flag.Bool`函数会创建一个新的对应布尔型标志参数的变量。有三个属性：第一个是命令行标志参数的名字:`n`，然后是该标志参数的默认值（这里是`false`），最后是该标志参数对应的描述信息。如果用户在命令行中输入了一个无效的标志参数，或者输入`-h`或者`-help`参数，那么将打印所有标志参数的名字，默认值和描述信息。程序中的`n`变量指向对应的命令行标志参数变量的指针，因此必须用`*n`形式的指针语法间接引用它们。

当程序运行时，必须在使用标志参数对应的变量之前先调用`flag.Parse`函数，用于更新每个标志参数对应的变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过`flag.Args`函数来访问，返回值是对应一个字符串类型的`slice`。如果在`flag.Parse`函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用`os.Exit(2)`终止程序。

**new函数**

另一个创建变量的方法是调用`new`函数。表达式`new(T)`将创建一个`T`类型的匿名变量，初始化为`T`类型的零值，然后返回变量地址，返回的指针类型为`*T`。

~~~go
p := new(int)	//p， *int类型，指向匿名的int变量
fmt.Println(*p)	//0
*p = 2
fmt.Println(*p)	//2
~~~

用`new`创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时的变量名字，还可以在表达式中使用`new(T)`。`new`函数是一种语法糖，不是一个新的基础概念。

一般而言，两个指针没有显式地指向同一变量，一般是不相等的，但是如果两个类型都是空的，即类型的大小为0，例如`struct{}`和`[0]int`有可能有相同的地址（需要具体的语言实现），并且对于类型大小为0的类型，可能导致Go语言的自动垃圾回收器有不同的行为。

**变量的生命周期**

 变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 

注：函数的右小括号可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间。

### 赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后统一更新坐标对应变量的值。这样可以交换两个变量的值：

~~~go
i, j = j, i
~~~

如果map查找，类型断言或通道接收出现在赋值语句的右边，都可能产生两个结果，有一个额外的布尔结果表示操作是否成功：

~~~go
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
~~~

上述三种情况也可能只产生一个结果。和变量声明一样，也可以用下划线空白标识符`__`来丢弃不需要的值。

**可赋值性**

只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。类型必须完全匹配，nil可以赋值给任何指针或者引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。

对于两个值是否可以用`==`或`!=`进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。

### 类型

变量或表达式的类型定义了对应存储值的属性特征：例如内存的存储大小，在内部是如何表达的，是否支持一些操作符，以及关联的方法集等。 在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。 

 一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。 

~~~go
type 类型名字 类型
~~~

 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。 

对于每一个类型`T`，都有一个对应的类型转换操作`T(x)`，用于将x转为T类型（如果T是指针类型，可能需要用小括弧包装T，比如`(*int)(0)`）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者时两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。在任何情况下，运行时不会发生转换失败的错误，错误只会发生在编译阶段。另外类型转换操作不是函数，只是改变值类型而已。

一个命名的类型可以提供书写方便，并且可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，成为类型的方法集。例如：

~~~go
func (c int)String() string{return fmt.Sprintf("%v",c)}
~~~

表示声明的是int类型的一个名叫String的方法，该方法返回该类型对象c的一个格式化字符串。

~~~go
c := 10
fmt.Println(c.String())
~~~

### 包和文件

目的是支持模块化、封装、单独编译和代码重用。  一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包`gopl.io/ch1/helloworld`对应的目录路径是`$GOPATH/src/gopl.io/ch1/helloworld`。 

每个包都对应一个独立的名字空间。例如`image`包中的Decode函数和在`unicode/utf16`包中的Decode函数时不同的。要在外部引用该函数，必须显式地使用`image.Decode`或`utf16.Decode`访问。

 在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。 

 一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。 

 每个包都有一个全局唯一的导入路径。  除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同 。 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。 

 包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化： 

~~~go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
~~~

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的`init`初始化函数来简化初始化工作。每个文件都可以包含多个`init`初始化函数。 在每个文件中的`init`初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。 

 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作 。

对于需要复杂处理的初始化，还可以通过将初始化逻辑包装为一个匿名函数处理：

~~~go
var pc [256]byte = func()(pc [256] byte) {
    for i,_:=range pc {
        pc[i] = pc[i/2]+byte[i&1]
    }
    return
}()
~~~

### 作用域

一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

 不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。 

句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。

声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包， 则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。 

控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。

一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。

 当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问 。

 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。 

 特别注意短变量声明语句的作用域范围 。当外层定义一个变量，内层通过短变量重新声明同名变量时，不会更新外层的变量。此时最好是使用赋值来避免重新声明。

## 基层的数据结构

 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。 

### 整形

 Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。 

 `int8`、`int16`、`int32`和`int64`四种截然不同大小的有符号整数类型，分别对应8、16、32、`64bit`大小的有符号整数，与此对应的是`uint8`、`uint16`、`uint32`和`uint64`四种无符号整数类型。 另外`int`和`uint`的具体位数根据平台确定，一般是32或者64位。

 还有一种无符号的整数类型`uintptr`，没有指定具体的bit大小但是足以容纳指针。`uintptr`类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。 

 关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列： 

~~~go
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
~~~

 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级。

 Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数： 

~~~go
&      位运算 AND
|      位运算 OR
^      位运算 XOR
&^     位清空 (AND NOT)
<<     左移
>>     右移
~~~

 位操作运算符`^`作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。位操作运算符`&^`用于按位置零（AND NOT）：如果对应y中bit位为1的话, 表达式`z = x &^ y`结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。 

 一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关的问题，而且也使得程序容易理解。 

 任何大小的整数字面值都可以用以0开始的八进制格式书写，例如`0666`；或用以`0x`或`0X`开头的十六进制格式书写，例如`0xdeadbeef`。十六进制数字可以用大写或小写字母。 

 当使用`fmt`包打印一个数值时，我们可以用`%d`、`%o`或`%x`参数控制输出的进制格式 如下：

~~~go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
~~~

 注意`fmt`的两个使用技巧。通常`Printf`格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的`[1]`副词告诉`Printf`函数再次使用第一个操作数。第二，%后的`#`副词告诉`Printf`在用%o、%x或%X输出时生成0、`0x`或`0X`前缀。 

 字符面值通过一对单引号直接包含对应字符。  字符使用`%c`参数打印，或者是用`%q`参数打印带单引号的字符 。

### 浮点数

 Go语言提供了两种精度的浮点数，`float32`和`float64 `。 一个`float32`类型的浮点数可以提供大约6个十进制数的精度，而`float64`则可以提供约15个十进制数的精度；通常应该优先使用`float64`类型，因为`float32`类型的累计计算误差很容易扩散，并且`float32`能精确表示的正整数并不是很大（译注：因为`float32`的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于`23bit`能表达的范围时，`float32`的表示将出现误差）。

~~~go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
~~~

 用`Printf`函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。 

 函数`math.IsNaN`用于测试一个数是否是非数`NaN`，`math.NaN`则返回非数对应的值。虽然可以用`math.NaN`来表示一个非法的结果，但是测试一个结果是否是非数`NaN`则是充满风险的，因为`NaN`和任何数都是不相等的（译注：在浮点数中，`NaN`、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示） :

~~~go
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
~~~

 如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败 。

### 复数

 Go语言提供了两种精度的复数类型：`complex64`和`complex128`，分别对应`float32`和`float64`两种浮点数精度。内置的complex函数用于构建复数，内建的`real`和`imag`函数分别返回复数的实部和虚部 。

~~~go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
~~~

 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如`3.141592i`或`2i`，它将构成一个复数的虚部，复数的实部是0。

在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像`1+2i`或与之等价的写法`2i+1`。

```Go
x := 1 + 2i
y := 3 + 4i
```

复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。

### 布尔型

 一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和<等比较操作也会产生布尔型的值。一元操作符`!`对应逻辑非操作，因此`!true`的值为`false`。

 布尔值可以和&&（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。

 布尔值并不会隐式转换为数字值0或1，反之亦然。 

### 字符串

 一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用`UTF8`编码的Unicode码点（rune）序列 。

 内置的`len`函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足`0 ≤ i< len(s)`条件约束。

```Go
s := "hello, world"
fmt.Println(len(s))     // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')
```

  如果试图访问超出字符串索引范围的字节将会导致panic异常 。

 第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。 

 子字符串操作`s[i:j]`基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。 

 同样，如果索引超出字符串范围或者j小于i的话将导致panic异常。 

 不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用`len(s)`作为结束的位置。 

 +操作符将两个字符串连接构造一个新字符串 。

 字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。 

字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：

```Go
s := "left foot"
t := s
s += ", right foot"
```

这并不会导致原始的字符串值被改变，但是变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。

```Go
fmt.Println(s) // "left foot, right foot"
fmt.Println(t) // "left foot"
```

因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：

```Go
s[0] = 'L' // compile error: cannot assign to s[0]
```

不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。

 字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可 。 可以通过十六进制或八进制转义在字符串面值中包含任意的字节。一个十六进制的转义形式是`\xhh`，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是`\ooo`，包含三个八进制的o数字（0到7），但是不能超过`\377`（译注：对应一个字节的范围，十进制为255）。每一个单一的字节表达一个特定的值。  

一个原生的字符串面值形式是`...`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写\`字符的，可以用八进制或十六进制转义或+"\`"连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统 。

原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。

```Go
const GoUsage = `Go is a tool for managing Go source code.

Usage:
    go command [arguments]
...`
```

 `UTF8`编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。如果第一个字节的高端bit为0，则表示对应`7bit`的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 

 变长的编码无法直接通过索引来访问第n个字符，但是`UTF8`编码获得了很多额外的优点。首先`UTF8`编码比较紧凑，完全兼容ASCII码，并且可以自动同步：它可以通过向前回朔最多3个字节就能确定当前字符编码的开始字节的位置。它也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看（译注：像`GBK`之类的编码，如果不知道起点位置则可能会出现歧义）。没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。同时`UTF8`编码的顺序和Unicode码点的顺序一致，因此可以直接排序`UTF8`编码序列。同时因为没有嵌入的`NULL`(0)字节，可以很好地兼容那些使用`NULL`作为字符串结尾的编程语言。 

 `unicode/utf8`包则提供了用于rune字符序列的`UTF8`编码和解码的功能。  Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：`\uhhhh`对应`16bit`的码点值，`\Uhhhhhhhh`对应`32bit`的码点值，其中h是一个十六进制数字；一般很少需要使用`32bit`的形式。每一个对应码点的`UTF8`编码。 

 对于小于256的码点值可以写在一个十六进制转义字节中，例如`\x41`对应字符'A'，但是对于更大的码点则必须使用`\u`或`\U`转义形式。因此，`\xe4\xb8\x96`并不是一个合法的rune字符，虽然这三个字节对应一个有效的`UTF8`编码的码点。 

 文本字符串采用`UTF8`编码只是一种惯例，但是对于循环的真正字符串并不是一个惯例，这是正确的。 

 `UTF8`字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。 

 将[]rune类型转换应用到`UTF8`编码的字符串，将返回字符串编码的Unicode码点序列 。

~~~go
s := "プログラム"
fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
r := []rune(s)
fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"
~~~

如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行`UTF8`编码：

```Go
fmt.Println(string(r)) // "プログラム"
```

将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的`UTF8`字符串：

```Go
fmt.Println(string(65))     // "A", not "65"
fmt.Println(string(0x4eac)) // "京"
```

如果对应码点的字符是无效的，则用`\uFFFD`无效字符作为替换：

```Go
fmt.Println(string(1234567)) // "?"
```

 标准库中有四个包对字符串处理尤为重要：`bytes`、`strings`、`strconv`和`unicode`包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。

 `bytes`包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的`[]byte`类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用`bytes.Buffer`类型将会更有效 。 

 `strconv`包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。 

 `unicode`包提供了`IsDigit`、`IsLetter`、`IsUpper`和`IsLower`等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像`ToUpper`和`ToLower`之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是`ToUpper`和`ToLower`，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。 

一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。

字符串和字节slice之间可以相互转换：

```Go
s := "abc"
b := []byte(s)
s2 := string(b)
```

从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。

 bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个`bytes.Buffer`变量并不需要初始化，因为零值也是有效的 。

 除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由`strconv`包提供这类转换功能。 

 将一个整数转为字符串，一种方法是用`fmt.Sprintf`返回一个格式化的字符串；另一个方法是用`strconv.Itoa`(“整数到ASCII”) 。 `FormatInt`和`FormatUint`函数可以用不同的进制来格式化数字 :

~~~go
fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
~~~

`fmt.Printf`函数的%b、%d、%o和%x等参数提供功能往往比`strconv`包的Format函数方便很多，特别是在需要包含有附加额外信息的时候：

```Go
s := fmt.Sprintf("x=%b", x) // "x=1111011"
```

如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：

```Go
x, err := strconv.Atoi("123")             // x is an int
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
```

`ParseInt`函数的第三个参数是用于指定整型数的大小；例如16表示`int16，0`则表示int。在任何情况下，返回的结果y总是`int64`类型，你可以通过强制类型转换将它转为更小的整数类型。

有时候也会使用`fmt.Scanf`来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。

### 常量

常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。

一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。

和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：

```Go
const (
    e  = 2.71828182845904523536028747135266249775724709369995957496696763
    pi = 3.14159265358979323846264338327950288419716939937510582097494459
)
```

所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：`len`、`cap`、`real`、`imag`、`complex`和`unsafe.Sizeof`。

因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分。

 一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。 

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：

```Go
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
```

如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是iota常量生成器语法。

**iota 常量生成器**

 常量声明可以使用`iota`常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个`const`声明语句中，在第一个声明的常量所在的行，`iota`将会被置为0，然后在每一个有常量声明的行加一。 

```Go
type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

 可以在复杂的常量表达式中使用iota :

~~~go
type Flags uint

const (
    FlagUp Flags = 1 << iota // is up
    FlagBroadcast            // supports broadcast access capability
    FlagLoopback             // is a loopback interface
    FlagPointToPoint         // belongs to a point-to-point link
    FlagMulticast            // supports multicast access capability
)
~~~

 随着iota的递增，每个常量对应表达式1 << iota，是连续的2的幂，分别对应一个bit位置。 

 Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或`float64`，或者是类似`time.Duration`这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有`256bit`的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 

 通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。 

math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

```Go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

如果`math.Pi`被确定为特定类型，比如`float64`，那么结果精度可能会不一样，同时对于需要`float32`或`complex128`类型值的地方则会强制需要一个明确的类型转换：

```Go
const Pi64 float64 = math.Pi

var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)
```

对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、`0i`和`\u0000`虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。

 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。 

 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理。

 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型 。

 无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的`float64`和`complex128`。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。 

## 复合数据类型

### 数组

 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列 。

 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的`len`函数将返回数组中元素的个数。 

 默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组 

在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，数组的定义可以简化为

```Go
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

 数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。 

数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样：

```Go
type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
```

在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。例如，

```Go
r := [...]int{99: -1}
```

定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。

 如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。 

 当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。 

 当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。 

 虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息，而且也没有任何添加或删除数组元素的方法。  一般使用slice来替代数组 。

### Slice

 Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。 

 一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的`len`和cap函数分别返回slice的长度和容量。 

 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠 。

 slice的切片操作`s[i:j]`，其中`0 ≤ i≤ j≤ cap(s)`，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的`slice`将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用`len(s)`代替。

 如果切片操作超出`cap(s)`的上限将导致一个`panic`异常，但是超出`len(s)`则是意味着扩展了`slice`，因为新`slice`的长度会变大： 加入有一个数组byte，有效下标为0-10。一个slice为`q = s[0:5]`。现在：`a := q[:6] `由于切片操作未超出原始数组的长度，因此有效。如果超过，则会引发一个`panic`异常。

字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作`x[m:n]`，并且都是返回一个原始字节系列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。`x[m:n]`切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。

因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。

 要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。 

~~~go
sli := []int{0,1,2}//声明切片
byt := [...]int{0,1,2}//声明数组
~~~

 和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的`bytes.Equal`函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较 。

 一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如`[]int{}`或`make([]int, 3)[3:]`。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。 

 如果你需要测试一个slice是否是空的，使用`len(s) == 0`来判断，而不应该用`s == nil`来判断。除了和nil相等比较外，一个`nil`值的slice的行为和其它任意0长度的slice一样；例如reverse(nil)也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。 

内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。

```Go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```

在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前`len`个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。

 内置的append函数用于向slice追加元素。 内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice，目标和源的位置顺序和`dst = src`赋值语句是一致的。两个slice可以共享同一个底层数组，甚至有重叠也没有问题。copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。 

 内置的append函数可能使用复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量。

更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：

```Go
type IntSlice struct {
    ptr      *int
    len, cap int
}
```

内置的append函数则可以追加多个元素，甚至追加一个slice。

```Go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```

函数参数中的最后的“...”省略号表示接收变长的参数为slice。

### Map

 哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。 

 在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。 

内置的make函数可以创建一个map：

```Go
ages := make(map[string]int) // mapping from strings to ints
```

可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：

```Go
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}
```

这相当于

```Go
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```

因此，另一种创建空的map的表达式是`map[string]int{}`。

使用内置的delete函数可以删除元素：

```Go
delete(ages, "alice") // remove element ages["alice"]
```

所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值。

即使map中不存在“bob”下面的代码也可以正常工作，因为ages["bob"]失败时将返回0。

```Go
ages["bob"] = ages["bob"] + 1 
```

 而且`x += y`和`x++`等简短赋值语法也可以用在map上 。

 但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作 。 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。 

 Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序 。

map类型的零值是nil，也就是没有引用任何哈希表。

```Go
var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
```

map上的大部分操作，包括查找、删除、`len`和`range`循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常：

```Go
ages["carol"] = 21 // panic: assignment to entry in nil map
```

在向map存数据前必须先创建map。

 通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值 。 有时候可能需要知道对应的元素是否真的是在map之中。例如，如果元素类型是一个数字，你可能需要区分一个已经存在的0，和不存在而返回零值的0 。

~~~go
var maptest map[string]int
fmt.Println(maptest == nil)//"true"
fmt.Println(len(maptest)==0)//"true"

test,ok := maptest["yang"]
if !ok{
    //"yang" is not a key in this map
}
~~~

或者这样：

~~~GO
if age, ok := ages["bob"]; !ok { /* ... */ }
~~~

 在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为`ok`，特别适合马上用于if条件判断部分。 

 和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现 。

 有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。 

 Map的value类型也可以是一个聚合类型，比如是一个map或slice。 比如：

~~~go
var graph = make(map[string]map[string]bool)
//此时value为map[string]bool类型
~~~

### 结构体

 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。 

 结构体变量的成员可以通过点操作符访问 ，可以对成员取地址，然后通过指针访问。点操作符也可以和指向结构体的指针一起工作：

~~~go
type test struct{
    name string
}
var testInstance *test
testInstance.name = "yy"
~~~

相当于下面语句：

~~~go
(*testInstance).name = "yy"
~~~

注：如果需要直接利用函数的返回值来引用结构体的成员，函数必须返回指针类型。这是因为赋值语句的左边并不确定是一个变量，调用函数返回的是值，并不是一个可取地址的变量。

 通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行 ：

~~~go
type test struct{
    name,address string
}
~~~

 结构体成员的输入顺序也有重要的意义。 

 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。 

 结构体类型往往是冗长的 。 因此，完整的结构体写法通常只在类型声明语句的地方出现 。

 一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含`*S`指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等 。

 结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。 

 如果结构体没有任何成员的话就是空结构体，写作`struct{}`。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。 

结构体初始化：第一种是按照成员定义的顺序进行初始化，如：

~~~go
type Point struct {x,y int}
p:=Point{1,2}
~~~

但是上面一种，一旦结构体发生变化，很有可能引起错误。因此，采用第二种形式：

~~~go
p:= Point{x:1,y:2}
~~~

采用这种形式，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。 两种写法不能混用。**两种形式都不能在外部包中初始化未导出的成员。**

由于在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量，因此想要在函数体重更改结构体的成员，需要使用指针。

~~~go
pp:=&Point{1,2}

pp:=new(Point)
*pp=Point{1,2}
//上面两种形式是等价的
~~~

**结构体嵌入和匿名成员**： Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。 例如：

~~~go
type Point struct {
    X, Y int
}
type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}
~~~

此时Wheel类型的变量可以直接访问成员Circle中的成员：

~~~go
var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
~~~

 因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。 

但是，结构体字面值没有简短表示匿名成员的语法。必须遵循类型声明时的结构，即：

~~~go
w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}
fmt.Printf("%#v\n", w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}

w.X = 42

fmt.Printf("%#v\n", w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}
~~~

 需要注意的是`Printf`函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。  因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员 。

 但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。 

 任何命名的类型都可以作为结构体的匿名成员 。 组合是Go语言中面向对象编程的核心 

### `JSON`

 `JSON`是一种用于发送和接收结构化信息的标准协议 。 Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的`encoding/json`、`encoding/xml`、`encoding/asn1`等包提供支持 

 基本的`JSON`类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过`JSON`使用的是`\Uhhhh`转义数字来表示一个`UTF-16`编码（译注：`UTF-16`和`UTF-8`一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且`UTF-16`还有大端和小端的问题），而不是Go语言的rune类型。 

 基础类型可以通过`JSON`的数组和对象类型进行递归组合。一个`JSON`数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个`JSON`数组可以用于编码Go语言的数组和slice。一个`JSON`对象是一个字符串到值的映射，写成一系列的`name:value`对形式，用花括号包含并以逗号分隔；`JSON`的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。

~~~go
boolean         true
number          -273.15
string          "She said \"Hello, BF\""
array           ["gold", "silver", "bronze"]
object          {"year": 1980,
                 "event": "archery",
                 "medals": ["gold", "silver", "bronze"]}
~~~

 将一个Go语言中类似movies的结构体slice转为`JSON`的过程叫编组（marshaling）。编组通过调用`json.Marshal`函数完成。 Marshal函数返还一个编码后的字节slice，包含很长的字符串，并且没有空白缩进 。

 在编码时，默认使用Go语言结构体的成员名字作为`JSON`的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码 ，因此需要首字母大写。

 结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:"value"键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。 

~~~GO
type Movie struct {
    Title  string
    Year   int  `json:"released"`
    Color  bool `json:"color,omitempty"`
    Actors []string
}
~~~

 `json`开头键名对应的值用于控制`encoding/json`包的编码和解码的行为，并且`encoding/...`下面其它的包也遵循这个约定。成员`Tag`中`json`对应值的第一部分用于指定`JSON`对象的名字，比如将Go语言中的`TotalCount`成员对应到`JSON`中的`total_count`对象。`Color`成员的`Tag`还带了一个额外的`omitempty`选项，表示当Go语言结构体成员为空或零值时不生成该`JSON`对象（这里false为零值）。 

 编码的逆操作是解码，对应将`JSON`数据解码为Go语言的数据结构，Go语言中一般叫`unmarshaling`，通过`json.Unmarshal`函数完成。将`JSON`编码解码为一个结构体`slice`，结构体中可以定义感兴趣的成员。通过定义合适的Go语言数据结构，我们可以选择性地解码`JSON`中感兴趣的成员。当`Unmarshal`函数调用返回，`slice`将被只含有同名的成员返回，其它`JSON`成员将被忽略。

 即使对应的`JSON`对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些`JSON`成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员`Tag`来指定对应的`JSON`名字。同样，在解码的时候也需要做同样的处理 。

 使用了`json.Unmarshal`函数来将`JSON`格式的字符串解码为字节`slice`。也可以使用基于流式的解码器`json.Decoder`，它可以从一个输入流解码`JSON`数据，尽管这不是必须的。同样还有一个针对输出流的`json.Encoder`编码对象。 

### 文本和HTML模板

 有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由`text/template`和`html/template`等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。 

 一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的`{{action}}`对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。 

 生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。 

## 函数

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。

```Go
func name(parameter-list) (result-list) {
    body
}
```

形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。

如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：

```Go
func f(i, j, k int, s, t string)                 { /* ... */ }
func f(i int, j int, k int,  s string, t string) { /* ... */ }
```

下列四种形式都是正确的：

```Go
func add(x int, y int) int   {return x + y}
func sub(x, y int) (z int)   { z = x - y; return}
func first(x int, _ int) int { return x }
func zero(int, int) int      { return 0 }
```

 函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或标识符。形参和返回值的变量名不影响函数标识符，也不影响它们是否可以以省略参数类型的形式表示。 

 每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。 

在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。

你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。

```Go
package math

func Sin(x float64) float //implemented in assembly language
```

### 递归

 函数可以是递归的，这意味着函数可以直接或间接的调用自身。 

 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。 

### 多返回值

 在Go中，一个函数可以返回多个值。 

 虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。 

调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:

```Go
links, err := findLinks(url)
```

如果某个值不被使用，可以将其分配给blank identifier。

 一个函数内部可以将另一个有多返回值的函数调用作为返回值 。

 如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。 

```Go
// CountWordsAndImages does an HTTP GET request for the HTML
// document url and returns the number of words and images in it.
func CountWordsAndImages(url string) (words, images int, err error) {
    resp, err := http.Get(url)
    if err != nil {
        return
    }
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        err = fmt.Errorf("parsing HTML: %s", err)
        return
    }
    words, images = countWordsAndImages(doc)
    return
}
func countWordsAndImages(n *html.Node) (words, images int) { /* ... */ }
```

 当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words，image，nil。基于以上原因，不宜过度使用bare return。 

### 错误

 在Go中有一部分函数总是能成功的运行。比如`strings.Contains`和`strconv.FormatBool`函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低。 

 还有一部分函数只要输入的参数满足一定条件，也能保证运行成功。比如`time.Date`函数，该函数将年月日等参数构造成`time.Time`对象，除非最后一个参数（时区）是nil。这种情况下会引发`panic`异常。`panic`是来自被调用函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生`panic`异常。 

 对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。 

 通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。 

 内置的error是接口类型。  error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型,我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。 

```Go
fmt.Println(err)
fmt.Printf("%v", err)
```

通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined),这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。

在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。

 Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。 

**错误处理策略**

 首先，也是最常用的方式是传播错误。 

 由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。 

 编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。 

 一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息 。

第二种错误处理策略： 如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。 

 第三种错误处理策略：如果错误发生后，程序无法继续运行，我们可以：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。 

 调用`log.Fatalf`可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。 

 第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数 ， 或者标准错误流输出错误信息 。log包中的所有函数会为没有换行符的字符串增加换行符。

第五种，也是最后一种策略：我们可以直接忽略掉错误。 虽然程序没有处理错误，但程序的逻辑不会因此受到影响。我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。 

 在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。 

**文件结尾错误**

 `io`包保证任何由文件结束引起的读取失败都返回同一个错误——`io.EOF `。 调用者只需通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。  因为文件结束这种错误不需要更多的描述，所以`io.EOF`有固定的错误信息——`“EOF”`。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像`io.EOF`一样采用固定的错误信息。 

### 函数值

 在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。 

 函数类型的零值是nil。调用值为nil的函数值会引起panic错误 。

 函数值可以与nil比较 。

 但是函数值之间是不可比较的，也不能用函数值作为map的key。 

 函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。 

 `fmt.Printf`的一个小技巧控制输出的缩进。`%*s`中的`*`会在字符串之前填充一些空格。 

~~~go
fmt.Printf("%*s</%s>\n",depth*2,"",data)
~~~

先输出`depth*2`数量的空格，再输出“”，最后再输出data。

### 匿名函数

 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量`（function literal）`，我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于`func`关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数`（anonymous function）`。

 函数字面量允许我们在使用函数时，再定义它。  更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：  

```Go
// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```

 函数squares返回另一个类型为` func() int` 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。

 函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。 

 变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。 

 当匿名函数需要被递归调用时，我们必须首先声明一个变量，再将匿名函数赋值给这个变量。如果不分成两部，函数字面量无法与该变量绑定，我们也无法递归调用该匿名函数。 

~~~go
var visit = func(items []string)
visit = func(items []string){
    //....
    visit(items)
}
~~~

**警告：捕获迭代变量**

 Go词法作用域的一个陷阱 。

```Go
var rmdirs []func()
for _, d := range tempDirs() {
    dir := d // NOTE: necessary!
    os.MkdirAll(dir, 0755) // creates parent directories too
    rmdirs = append(rmdirs, func() {
        os.RemoveAll(dir)
    })
}
// ...do some work…
for _, rmdir := range rmdirs {
    rmdir() // clean up
}
```

```go
var rmdirs []func()
for _, dir := range tempDirs() {
    os.MkdirAll(dir, 0755)
    rmdirs = append(rmdirs, func() {
        os.RemoveAll(dir) // NOTE: incorrect!
    })
}
```

 问题的原因在于循环变量的作用域。在上面的程序中，for循环语句引入了新的词法块，循环变量`dir`在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以`dir`为例，后续的迭代会不断更新`dir`的值，当删除操作执行时，for循环已完成，`dir`中存储的值等于最后一次迭代的值。这意味着，每次对`os.RemoveAll`的调用删除的都是相同的目录。  

 通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。比如下面的变量`dir`， 

```Go
for _, dir := range tempDirs() {
    dir := dir // declares inner dir, initialized to outer dir
    // ...
}
```

这个问题不仅存在基于range的循环，在下面的例子中，对循环变量i的使用也存在同样的问题：

```Go
var rmdirs []func()
dirs := tempDirs()
for i := 0; i < len(dirs); i++ {
    os.MkdirAll(dirs[i], 0755) // OK
    rmdirs = append(rmdirs, func() {
        os.RemoveAll(dirs[i]) // NOTE: incorrect!
    })
}
```

### 可变参数

 参数数量可变的函数称为可变参数函数。 

`Printf`首先接收一个必备的参数，之后接收任意个数的后续参数。

在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。

 调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。如果原始参数已经是切片类型，只需在最后一个参数后加上省略符。 

~~~go
value := []int{1,2,3,4}
sum(value...)
~~~

 虽然在可变参数函数内部，`...int` 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。 

```Go
func f(...int) {}
func g([]int) {}
fmt.Printf("%T\n", f) // "func(...int)"
fmt.Printf("%T\n", g) // "func([]int)"
```

 可变参数函数经常被用于格式化字符串。  函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收`Printf`风格的格式化字符串。 

 interface{}表示函数的最后一个参数可以接收任意类型 。

###  Deferred函数

 只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。 

 defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。 

 在处理其他资源时，也可以采用defer机制，比如对文件的操作。类似于C++的RAII。

 调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。  通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间 。 需要注意一点：不要忘记defer语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。 

 defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。 

 被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值。

### Panic异常

 Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起`painc`异常。 

 一般而言，当panic异常发生时，程序会中断运行，并立即执行在该`goroutine`  中被延迟的函数（defer 机制）。  随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个`goroutine`，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。 

 不是所有的`panic`异常都来自运行时，直接调用内置的`panic`函数也会引发`panic`异常；`panic`函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用`panic`。 

 断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码。 

 虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。  在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。 

 为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用`printStack`输出堆栈信息。 

```Go
func main() {
    defer printStack()
    f(3)
}
func printStack() {
    var buf [4096]byte
    n := runtime.Stack(buf[:], false)
    os.Stdout.Write(buf[:n])
}
```

` runtime.Stack`可以输出已经被释放函数的信息。在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。 

### Recover捕获异常

 通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。 

 如果在`deferred`函数中调用了内置函数`recover`，并且定义该`defer`语句的函数发生了`panic`异常，`recover`会使程序从`panic`中恢复，并返回`panic value`。导致`panic`异常的函数不会继续运行，但能正常返回。在未发生`panic`时调用`recover`，`recover`会返回`nil`。 

 deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用`runtime.Stack`往错误信息中添加完整的堆栈调用信息。 

 不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。 

 虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的`API`应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。 

 安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理 。

 有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。 

## 方法

### 方法声明

 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。 

~~~go
type Point struct{X,Y float64}
func Distance(p,q,Point)float64{
    return math.Hypot(q.X-p.X,q.Y-p.Y)
}

func (p Point) Distance(q Point)float64{
    return math.Hypot(q.X-p.X,q.Y-p.Y)
}
~~~

 上面的代码里那个附加的参数p，叫做方法的接收器(receiver) 。 在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。 

 在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。 

` p.Distance`的表达式叫做选择器 。 会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个`struct`类型的字段，比如`p.X`。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用`p.X`时会有歧义 。

 因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。 

 可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者interface。 

 对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名 。 没有必要非在方法名之前加类型名来消除歧义 。 方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字 。

### 基于指针对象的方法

 当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。 

用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：

```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```

这个方法的名字是`(*Point).ScaleBy`。这里的括号是必须的；没有括号的话这个表达式可能会被理解为`*(Point.ScaleBy)`。

 在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。 

只有类型(Point)和指向他们的指针`(*Point)`，才可能是出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：

```go
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

想要调用指针类型方法`(*Point).ScaleBy`，只要提供一个Point类型的指针即可，像下面这样。

```go
r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // "{2, 4}"
```

或者这样：

```go
p := Point{1, 2}
pptr := &p
pptr.ScaleBy(2)
fmt.Println(p) // "{2, 4}"
```

或者这样:

```go
p := Point{1, 2}
(&p).ScaleBy(2)
fmt.Println(p) // "{2, 4}"
```

go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：

```go
p.ScaleBy(2)
```

编译器会隐式地帮我们用&p去调用`ScaleBy`这个方法。这种简写方法只适用于“变量”，包括`struct`里的字段比如`p.X`，以及`array`和`slice`内的元素比如`perim[0]`。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：

```go
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

但是我们可以用一个`*Point`这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号`*`来取到该变量即可。编译器在这里也会给我们隐式地插入`*`这个操作符，所以下面这两种写法等价的：

```Go
pptr.Distance(q)
(*pptr).Distance(q)
```

在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：

不论接收器的实际参数和其形式参数是相同，比如两者都是类型T或者都是类型`*T`：

```go
Point{1, 2}.Distance(q) //  Point
pptr.ScaleBy(2)         // *Point
```

或者接收器实参是类型T，但接收器形参是类型`*T`，这种情况下编译器会隐式地为我们取变量的地址：

```go
p.ScaleBy(2) // implicit (&p)
```

或者接收器实参是类型`*T`，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：

```go
pptr.Distance(q) // implicit (*pptr)
```

如果命名类型T（译注：用`type xxx`定义的类型）的所有方法都是用T类型自己来做接收器（而不是`*T`），那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如`time.Duration`的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。

不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。

在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。

**nil也是一个合法的接收器类型**

 方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。 

 map类型，并且间接引用了其key/value对，因此对这个map里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为nil，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的） 。

### 通过嵌入结构来扩展类型

 在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中(译注：访问需要通过该指针指向的对象去取)。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。 

 一个`struct`类型也可能会有多个匿名字段。  当编译器解析一个选择器到方法时，比如`p.ScaleBy`，它会首先去找直接定义在这个类型里的`ScaleBy`方法，然后找被`ColoredPoint`的内嵌字段们引入的方法，然后去找`Point`和`RGBA`的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。

 方法只能在命名类型(像Point)或者指向类型的指针上定义 。 

### 方法值和方法表达式

可以选择一个方法，并且在同一个表达式里执行，比如常见的`p.Distance()`形式，实际上是将其分成两步来执行是可能的，类似C++的`bind`调用。将`p.Distance`叫做选择器，选择器会返回一个方法”值“->一个将方法绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用，即调用时不需要指定接收器，只要传入函数的参数即可。：

~~~go
p := Point{1,2}
q := Point{4,6}
distanceFromP := p.Distance
distanceFromP(q)
~~~

 在一个包的`API`需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法"值"会非常实用 。

~~~go
type Rocket struct{/**/}
func (r *Rocket)Launch(){/*...*/}
r ；= new(Rocket)
time.AfterFunc(time.Second,func(){r.Launch()})
~~~

直接用方法“值”传入`AfterFunc`的话可以更为简洁：

~~~go
time.AfterFunc(time.Second,r.Launch())
~~~

相当于C++的lambda函数，或者函数指针。

和方法"值"相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(`p.Distance`)语法来指定方法的接收器。

 当T是一个类型时，方法表达式可能会写作`T.f`或者`(*T).f`，会返回一个函数"值"，这种函数会将其第一个参数用作接收器，所以可以用通常(译注：不写选择器)的方式来对其进行调用。类似于C++的`mem_fn` 。

~~~go
p := Point{1,2}
q := Point{3,4}
distance := Point.Distance
distance(p,q)
scale := (*Point).ScaleBy
scale(&p,2)
~~~

 根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。可以根据选择来调用接收器各不相同的方法。 

### 封装

 一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。 

 Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于`struct`或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个`struct`。 

 基于名字的手段使得在语言中最小的封装单元是`package`，而不是像其它语言一样的类型。一个`struct`类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。 

 封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。 

 第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的`api`情况下能得到更大的自由。 

 封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。 

 Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证`API`兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。 

## 接口

 接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。 

 一方面这个约定需要调用者提供具体类型的值 。 这些类型都有一个特定签名和行为函数。 另一方面这个约定保证了`Fprintf`接受任何满足`io.Writer`接口的值都可以工作。`Fprintf`函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用Write函数的值。 

 一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。 

### 接口类型

 接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。 

 与结构体内嵌一个，可以用一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌 。也可以混用两种形式。

### 实现接口的条件

 接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。 

```go
var w io.Writer
w = os.Stdout           // OK: *os.File has Write method
w = new(bytes.Buffer)   // OK: *bytes.Buffer has Write method
w = time.Second         // compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc = os.Stdout         // OK: *os.File has Read, Write, Close methods
rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method
```

这个规则甚至适用于等式右边本身也是一个接口类型

```go
w = rwc                 // OK: io.ReadWriteCloser has Write method
rwc = w                 // compile error: io.Writer lacks Close method
```

因为`ReadWriter`和`ReadWriteCloser`包含所有Writer的方法，所以任何实现了`ReadWriter`和`ReadWriteCloser`的类型必定也实现了Writer接口

 一个类型持有一个方法的表示当中的细节。  对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个`*T`的指针。还记得在T类型的参数上调用一个`*T`的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。但这仅仅是一个语法糖：T类型的值不拥有所有`*T`指针的方法，这样它就可能只实现了更少的接口。 

```go
type IntSet struct { /* ... */ }
func (*IntSet) String() string
var _ = IntSet{}.String() // compile error: String requires *IntSet receiver
```

但是我们可以在一个IntSet值上调用这个方法：

```go
var s IntSet
var _ = s.String() // OK: s is a variable and &s has a String method
```

然而，由于只有`*IntSet`类型有String方法，所以也只有`*IntSet`类型实现了fmt.Stringer接口：

```go
var _ fmt.Stringer = &s // OK
var _ fmt.Stringer = s  // compile error: IntSet lacks String method
```

 接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到。

 interface{}被称为空接口类型 。 空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。 

```go
var any interface{}
any = true
any = 12.34
any = "hello"
any = map[string]int{"one": 1}
any = new(bytes.Buffer)
```

 因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，尝试文档化和断言这种关系几乎没有用，所以并没有通过程序强制定义。 

 非空的接口类型比如`io.Writer`经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。 

 但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。  甚至基本的类型也可能会实现一些接口 。

 一个具体的类型可能实现了很多不相关的接口 。 每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。 