# Go语言编程

## 入门

### hello,world

Go语言的代码通过包`package`组织，包类似于库或者模块。一个包由单个目录下的一个或多个`.go`源代码文件组成，目录定义包的作用。每个源文件都以一条`package`声明语句开始，表示该文件属于哪个包，紧跟着一系列导入`import`的包，之后是存储在这个文件里的程序语句。

`main`包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在`main`里的`main`函数是整个程序执行时的入口。

`import`声明必须跟在文件的`package`声明之后。随后，则是组成程序的函数、变量、常亮、类型的声明语句（分别由关键字`func`、`var`、`const`和`type`定义）。

一个函数的声明由`func`关键字、函数名、参数列表、返回值列表以及包含在大括号里的函数体组成。

### 命令行参数

`os`包以跨平台的方式，可通过`os`包的`Args`变量获取。`os.Args`变量是一个字符串的切片。用`s[i]`访问单个元素，用`s[m:n]`获取子序列，区间索引时，Go也采用左闭右开形式，`s[m:n]`包含n-m个元素。

`os.Args`的第一个元素`os.Args[0]`是命令本身的名字，其他元素则是程序启动时传给它的参数。要获取其他所有的命令行参数可以用`os.Args[1:len(os.Args)]`或者`os.Args[1:]`。

如果程序里需要导入多个包，可以每个包写一份`import`声明，也可以用`()`括起来，比如：

~~~go
import(
    "fmt"
    "os"
)
~~~

注释语句以`//`开头。按照惯例，在每个包的包声明前添加注释，对于`main package`，注释包含一句或几句话，从整体角度对程序做个描述。

`var`声明定义变量。变量会在声明时直接初始化。如果变量没有显示初始化，则被隐式地初始化成空字符串。

`:=`是短变量声明的一部分，这是定义一个或多个变量并根据他们的初始值为这些变量赋予适当类型的语句。

`++`和`--`是语句，不像C系的其他语言是表达式。所以`j=i++`非法，而且`++`和`–-`都只能放在变量名后面，因此`–-i`非法

Go语句只有`for`循环这一种循环语句。`for`循环有多种形式，其中一种如下：

~~~go
for initialization; condition; post{
    //zero or more statements
}
~~~

`for`循环的三个部分不需括号包围。大括号强制要求，左大括号必须和`post`语句在同一行。

`initialization`语句是可选的，在循环开始前执行。`initlization`如果存在，必须是一条简单语句，即短变量声明、自增语句、赋值语句或函数调用。`condition`是一个布尔表达式，其值在每次循环迭代开始时计算。`post`语句在循环体执行结束后执行，之后再次对`condition`求值。

`for`循环的这三个部分每个都可以被省略，如果省略`initlization`和`post`，分号也可以被省略：

~~~go
//a traditional "while" loop
for condition{
    //...
}
~~~

如果连`condition`也省略，可以这样

~~~go
//a traditional infinite loop
for{
    //...
}
~~~

这样就会变成无限循环。可以采用`break`或者`return`语句。

`for`循环的另一种形式，在某种数据类型的区间上遍历

~~~go
for index, arg := range os.Args[1:]{
    fmt.Println("下标：",index,"\t",arg)
}
~~~

每次循环迭代，`range`产生一对值：索引以及该索引处的元素值。由于Go语言不允许使用无用的局部变量，这样会导致编译错误。因此如果不想要用索引，可以采用空标识符，即`__`（下划线）。空标识符可用于任何语法需要变量名但程序逻辑不需要的时候，类似于C++的`std::ignore`。

声明变量的形式有：

~~~go
s := ""
var s string
var s = ""
var s string = ""
~~~
第一种是短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为“”。第三种形式用的少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式的某个，初始值重要地话就显式地指定变量的类型，否则使用隐式初始化。

`+=`连接字符串，产生新字符串，并把它赋值给`s`。`s`原来的内容不再使用，将在适当时机对它进行垃圾回收。如果连接设计的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用`strings`包的`join`函数：

~~~go
func main(){
    fmt.Println(strings.Join(os.Args[1:]," "))
}
~~~

另外，还可以直接输出切片：

~~~go
fmt.Println(os.Args[1:])
~~~

最后每个元素都放在一对方括号里。

### 查找重复的行

`if`语句类似`for`循环一样，两边不加括号。

~~~go
if condition{
    //...
}
~~~

`map`存储了键/值的集合，对集合元素，提供了常数时间的存，取或测试操作。键可以是任意类型，只要其键的值能用`==`运算符比较，值可以是任意类型。`map[string]int`定义的键是`string`，值是`int`。内建函数`make`具有很强的作用，例如：

~~~go
counts := make(map[string]int)
~~~

就是创建一个键是string，值是int的空map。Go中的map是哈希表，类似C++的unordered_map。同样，对map中不存在的元素使用`[]`，将对其赋其值类型的零值，对于`int`就是0。

`bufio`包使处理输入和输出方便又高效。`Scanner`类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。

使用短变量声明创建`bufio.Scanner`类型的变量`input`。

~~~go
input := bufio.NewScanner(os.Stdin)
~~~

该变量从程序的标准输入中读取内容。每次调用`input.Scan()`,即读取下一行，并移除行末的换行符；读取的内容可以调用`input.Text()`得到。`Scan`函数在读到一行时返回`true`，不再有返回时，返回`false`。

`fmt.Printf`函数类似于C语言的`printf`，可以产生格式化输出。该函数的首个参数是个格式化字符串，指定后续参数被如何格式化。每个参数的格式取决于“转换字符”，形式为百分号后跟一个字母。Go程序员称之为动词。

|    %d    |                 十进制整数                 |
| :------: | :----------------------------------------: |
| %x,%o,%b |        十六进制，八进制，二进制整数        |
| %f,%g,%e |                   浮点数                   |
|    %t    |             布尔：true或false              |
|    %c    |            字符（unicode码点）             |
|    %s    |                   字符串                   |
|    %q    | 带双引号的字符串“abc”或者带单引号的字符‘c’ |
|    %v    |               变量的自然形式               |
|    %T    |                 变量的类型                 |
|    %%    |             字面上的百分号标志             |

默认情况下，`Printf`不会换行。按照惯例，以字母`f`结尾的格式化函数，如`log.Printf`和`fmt.Errorf`都采用`fmt.Printf`的格式化准则。而已`ln`结尾的格式化函数，则遵循`Println`的方式，以跟`%v`差不多的方式格式化参数，并在最后添加一个换行符。后缀`f`指`format`，`ln`指`line`。

`os.Open`函数返回两个值。第一个值是被打开的文件（`*os.File`），其后被`Scanner`读取。返回的第二个值是内置`error`类型的值。如果`err`等于内置值`nil`，那么文件被成功打开。读取文件，直到文件结束，然后调用`Close`关闭该文件，并释放占用的所有资源。相反，如果`err`的值不是`nil`，说明文件打开失败，这种情况下，错误值描述了所遇到的问题。

函数和包级别的变量可以任意顺序声明，并不影响其被调用。

`make`函数可以创建数据结构，比如`make(map[string]int)`创建一个`map`的引用。`map`作为参数传递给某函数时，该函数接受这个引用的一份拷贝，被调用函数对`map`底层数据结构的任何修改，调用者函数都可以通过持有的`map`的引用看到。类似于C++的引用传递。

`ReadFile`函数返回一个字节切片，必须把它切换为`string`，才能用`strings.Split`分割。

### GIF动画

常量是指在程序编译后始终都不会变化的值，一般出现在包级别的。但也可以声明定义在函数体内部，那么这种常量就只能在函数体内用。目前常量声明的值必须是一个数字值/字符串或者一个固定的boolean值。

`[]color.Color{...}`和`gif.GIF{...}`这两个表达式是复合声明。这是实例化Go语言里的符合类型的一种写法。前者生成的是一个`slice`切片，后者生成的是一个`struct`结构体。如下：

~~~go
//gif
type GIF struct {
	Image []*image.Paletted 
	Delay []int         
	LoopCount int
	Disposal []byte
	Config image.Config
	BackgroundIndex byte
}

anim := gif.GIF{LoopCount : 1}
~~~

上述是实例化一个GIF结构体，并且将其中的`LoopCount`成员初始化为1，其他成员会被设置各自类型默认的零值。

### 获取URL

主要使用`net/http`和`io/ioutil`包。其中`http.Get`函数是创建`HTTP`请求的函数，如果获取过程没有出错，那么就会在返回的结果中得到访问的请求结果。返回的Response指针的`Body`字段包括一个可读的服务器响应流。`ioutil.ReadAll`函数从`response`中读取到全部内容，将其结果保存到一个变量中。`response.Body.Close`函数关闭`response`的`Body`流，防止资源泄露。

### 并发获取多个URL

`goroutine`是一种函数的并发执行方式，而`channel`是用来在`goroutine`之间进行参数传递。`main`函数本身也运行在一个`goroutine`中，而`go function`则表示创建一个新的`goroutine`，并在这个新的`goroutine`中执行这个函数。

使用`make`函数创建一个传递`string`类型参数的`channel`：

~~~go
ch := make(chan string)
~~~

`ioutil.Discard`输出流相当于一个垃圾桶。使用`io.Copy`可将一个字节数组拷贝到一个输出流，并返回长度。

当一个`goroutine`尝试在一个`channel`上做`send`或者`receive`操作时，这个`goroutine`会阻塞在调用处，直到另一个`goroutine`从这个`channel`里接收或者写入值，这样两个`goroutine`才会继续执行`channel`操作之后的逻辑。

~~~go
ch := make(chan string)
ch <- string("nihao")//将数据写到channel
fmt.Println(<-ch)//从channel中读取数据
~~~

### Web服务

主要使用

~~~go
http.HandleFunc("/",func(w http.ResponseWriter, r *http.Request){
	//...
})
~~~

### 本章总结

`switch`：

~~~go
switch coinflip () {
    case "heads":
    	heads++
    case "tails":
    	tails++
    default:
    fmt.Println("landed on edge!")
}
~~~

Go语言不需要显式地在每一个`case`后写`break`，语言默认执行完`case`后的逻辑语句会自动退出。如果想相邻的几个`case`都执行同一逻辑，需要显式地写上一个`fallthrough`语句来覆盖这种默认行为。

另外Go语言的`switch`可以不带对象（`switch`不带操作对象时，默认用`true`值代替，然后将每个`case`的表达式和true值进行比较；可以直接罗列多种条件，像其他语言的`if else`一样，如下：

~~~go
func Signum(x int)int {
    switch {
        case x>0:
        	return +1
        default:
        	return 0
        case x<0:
        	return -1
    }
}
~~~

这种叫`无tag switch`；这和`switch true`等价。

类似于`for`和`if`控制语句一样，`switch`也可以紧跟一个简短的变量声明，一个自增表达式/赋值语句，或者一个函数调用。

**命名类型**：类型声明可以很方便地给一个特殊类型一个名字。因为`struct`类型声明非常长，可以给`struct`取一个名字。例如：

~~~go
type Point struct {
    X, Y int
}

var p Point
~~~

**指针**：Go语言提供了指针。指针时一种直接存储了变量的内存地址的数据类型。Go语言的指针没有C语言这么强。指针是可见的内存地址，`&`操作符可以返回一个变量的内存地址，并且`*`操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像C语言里可以对指针进行加或减操作。

**方法和接口**：方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。

**包(package)**：Go语言提供了很多包，并且这些包是可以扩展的。借助`godoc`工具可以直接在本地命令行阅读标准库的文档：

~~~go
go doc http.ListenAndServe
---------------------------------------------------------------------
package http // import "net/http"

func ListenAndServe(addr string, handler Handler) error
    ListenAndServe listens on the TCP network address addr and then calls Serve
    with handler to handle requests on incoming connections. Accepted
    connections are configured to enable TCP keep-alives.

    The handler is typically nil, in which case the DefaultServeMux is used.

    ListenAndServe always returns a non-nil error.
~~~

**注释**：在源文件开头写注释和在每个函数前写一个说明函数行为的注释是一个好习惯，可以被`godoc`这样的工具检测到。并且在执行命令时显示这些注释。

多行注释可以用`/*...*/`来包裹。

## 程序结构

### 命名

Go语言中的函数名，变量名，常量名，类型名，语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母，数字或下划线。大写字母和小写字母是不同的。

**关键字**：

~~~go
break		default			func	interface	select
case		defer			go		map			struct
chan		else			goto	package		switch
const		fallthrough		if		range		type
continue	for				import	return		var
~~~

预定义名字：

~~~go
内建常量：true	false	iota	nil

内建类型：int	int8	int16	int32	int64
		uint	uint8	uint16	uint32	uint64	uintptr
		float32	float64	complex128	complex64
		bool	byte	string	error

内建函数：make	len	cap	new	append	copy	close	delete
		complex	real	imag
		panic	recover
~~~

这些内部预定义的名字不是关键字，可以重新定义，但是要避免过度定义引起混乱。

如果一个名字是在函数内部定义，那么它就在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（必须是在函数外部定义的包级别的名字，包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如`fmt`包的`Printf`函数就是导出的，可以在`fmt`包外部访问。包本身的名字一般是用小写字母。

名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。通常来说，如果一个名字的作用域比较大，声明周期比较长，那么用长的名字就会更有意义。

Go语言推荐使用驼峰式命名，当名字由几个单词组成，优先使用大小写分割，而不是优先使用下划线分割。但是对于缩略词，采用全部大写的形式，例如：`ASCII`或者`HTML`。

### 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：`var`，`const`，`type`和`func`。分别对应变量，常量，类型和函数实体对象的声明。

在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。

一个函数的声明由一个函数名字，参数列表（由函数的调用者提供参数变量的具体值），一个可选的返回值列表和包含函数体定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，一次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。

### 变量

`var`声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

~~~go
var 变量名字  类型 = 表达式
~~~

其中`类型`或`= 表达式`两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。数值类型变量对应的零值是0，布尔类型的变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括`slice`，指针，`map`，`chan`和函数）变量对应的零值是`nil`。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。 

在一个声明语句中可以同时声明一组变量，或用一组初始化声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：

~~~go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
~~~

如果要同时定义多个类型的变量，同时没有初始化表达式，可以采用如下形式：

~~~go
var (
	i int
    f float
    s string
)
~~~

初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。

一组变量也可以通过调用一个函数，由函数返回的多个值进行初始化

~~~go
var f, err = os.Open(name)
~~~

**简短变量声明**

在函数内部，可以使用简短变量声明语句的形式用于声明或初始化局部变量。以`名字 := 表达式`形式声明变量，变量的类型根据表达式来自动推导。

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。`var`形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后被重新赋值而初始值无关紧要的地方。

和`var`形式声明语句一样，简短变量声明语句可以用来声明和初始化一组变量：

~~~go
i, j := 0,1
~~~

但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如`for`语句的循环初始化语句部分。

`:=`是一个变量声明语句，而`=`是一个变量赋值操作。不要混肴多个变量的声明和元组的多重赋值，后者是将右边各个表达式的值赋值给左边对应位置的各个变量：

~~~go
i, j = j, i//交换i和j的值
~~~

和普通`var`形式的变量声明语句一样，简短变量声明语句可以用函数的返回值来声明和初始化变量：

~~~go
f, err := os.Open(name)
if err != nil {
    return err
}
f.Close()
~~~

注：简短变量声明的坐边变量可能并不是全部刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短的变量声明语句对这些已经声明过的变量就只有赋值行为了。即简短变量声明至少有一个新的变量。

~~~go
//success
in, err := os.Open(infile)
//...
out, err := os.Open(outfile)

//fail
f, err := os.Open(infile)
//...
f, err := os.Open(outfile)
~~~

解决的方法是第二个简短变量声明改用普通的多重赋值语句。简短声明变量语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

**指针**

~~~go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
~~~

与C语言类似。 任何类型的指针的零值都是nil。如果p指向某个有效变量，那么`p != nil`测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等 。

在Go语言中，返回函数局部变量的地址是安全的。即：

~~~go
var p = f()
func f()*int{
    v := 1
    return &v
}
~~~

每次调用f函数返回的结果不同：

~~~go
fmt.Println(f() == f())//false
~~~

因此指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。

指针会创建别名，其他引用类型也会创建别名，例如`slice`，`map`和`chan`，甚至结构体，数组和接口等都会创建所引用变量的别名。

指针是实现标准库中`flag`包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。

~~~go
var n = flag.Bool("n",false,"omit trailing newline")
~~~

比如：`flag.Bool`函数会创建一个新的对应布尔型标志参数的变量。有三个属性：第一个是命令行标志参数的名字:`n`，然后是该标志参数的默认值（这里是`false`），最后是该标志参数对应的描述信息。如果用户在命令行中输入了一个无效的标志参数，或者输入`-h`或者`-help`参数，那么将打印所有标志参数的名字，默认值和描述信息。程序中的`n`变量指向对应的命令行标志参数变量的指针，因此必须用`*n`形式的指针语法间接引用它们。

当程序运行时，必须在使用标志参数对应的变量之前先调用`flag.Parse`函数，用于更新每个标志参数对应的变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过`flag.Args`函数来访问，返回值是对应一个字符串类型的`slice`。如果在`flag.Parse`函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用`os.Exit(2)`终止程序。

**new函数**

另一个创建变量的方法是调用`new`函数。表达式`new(T)`将创建一个`T`类型的匿名变量，初始化为`T`类型的零值，然后返回变量地址，返回的指针类型为`*T`。

~~~go
p := new(int)	//p， *int类型，指向匿名的int变量
fmt.Println(*p)	//0
*p = 2
fmt.Println(*p)	//2
~~~

用`new`创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时的变量名字，还可以在表达式中使用`new(T)`。`new`函数是一种语法糖，不是一个新的基础概念。

一般而言，两个指针没有显式地指向同一变量，一般是不相等的，但是如果两个类型都是空的，即类型的大小为0，例如`struct{}`和`[0]int`有可能有相同的地址（需要具体的语言实现），并且对于类型大小为0的类型，可能导致Go语言的自动垃圾回收器有不同的行为。

**变量的生命周期**

 变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 

注：函数的右小括号可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间。

### 赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后统一更新坐标对应变量的值。这样可以交换两个变量的值：

~~~go
i, j = j, i
~~~

如果map查找，类型断言或通道接收出现在赋值语句的右边，都可能产生两个结果，有一个额外的布尔结果表示操作是否成功：

~~~go
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
~~~

上述三种情况也可能只产生一个结果。和变量声明一样，也可以用下划线空白标识符`__`来丢弃不需要的值。

**可赋值性**

只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。类型必须完全匹配，nil可以赋值给任何指针或者引用类型的变量。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。

对于两个值是否可以用`==`或`!=`进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。

### 类型

变量或表达式的类型定义了对应存储值的属性特征：例如内存的存储大小，在内部是如何表达的，是否支持一些操作符，以及关联的方法集等。 在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。 

 一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。 

~~~go
type 类型名字 类型
~~~

 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。 

对于每一个类型`T`，都有一个对应的类型转换操作`T(x)`，用于将x转为T类型（如果T是指针类型，可能需要用小括弧包装T，比如`(*int)(0)`）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者时两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。在任何情况下，运行时不会发生转换失败的错误，错误只会发生在编译阶段。另外类型转换操作不是函数，只是改变值类型而已。

一个命名的类型可以提供书写方便，并且可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，成为类型的方法集。例如：

~~~go
func (c int)String() string{return fmt.Sprintf("%v",c)}
~~~

表示声明的是int类型的一个名叫String的方法，该方法返回该类型对象c的一个格式化字符串。

~~~go
c := 10
fmt.Println(c.String())
~~~

### 包和文件

目的是支持模块化、封装、单独编译和代码重用。  一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包`gopl.io/ch1/helloworld`对应的目录路径是`$GOPATH/src/gopl.io/ch1/helloworld`。 

每个包都对应一个独立的名字空间。例如`image`包中的Decode函数和在`unicode/utf16`包中的Decode函数时不同的。要在外部引用该函数，必须显式地使用`image.Decode`或`utf16.Decode`访问。

 在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。 

 一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。 

 每个包都有一个全局唯一的导入路径。  除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同 。 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。 

 包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化： 

~~~go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
~~~

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的`init`初始化函数来简化初始化工作。每个文件都可以包含多个`init`初始化函数。 在每个文件中的`init`初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。 

 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作 。

对于需要复杂处理的初始化，还可以通过将初始化逻辑包装为一个匿名函数处理：

~~~go
var pc [256]byte = func()(pc [256] byte) {
    for i,_:=range pc {
        pc[i] = pc[i/2]+byte[i&1]
    }
    return
}()
~~~

