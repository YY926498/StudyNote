# Go语言编程

## 入门

### hello,world

Go语言的代码通过包`package`组织，包类似于库或者模块。一个包由单个目录下的一个或多个`.go`源代码文件组成，目录定义包的作用。每个源文件都以一条`package`声明语句开始，表示该文件属于哪个包，紧跟着一系列导入`import`的包，之后是存储在这个文件里的程序语句。

`main`包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在`main`里的`main`函数是整个程序执行时的入口。

`import`声明必须跟在文件的`package`声明之后。随后，则是组成程序的函数、变量、常亮、类型的声明语句（分别由关键字`func`、`var`、`const`和`type`定义）。

一个函数的声明由`func`关键字、函数名、参数列表、返回值列表以及包含在大括号里的函数体组成。

### 命令行参数

`os`包以跨平台的方式，可通过`os`包的`Args`变量获取。`os.Args`变量是一个字符串的切片。用`s[i]`访问单个元素，用`s[m:n]`获取子序列，区间索引时，Go也采用左闭右开形式，`s[m:n]`包含n-m个元素。

`os.Args`的第一个元素`os.Args[0]`是命令本身的名字，其他元素则是程序启动时传给它的参数。要获取其他所有的命令行参数可以用`os.Args[1:len(os.Args)]`或者`os.Args[1:]`。

如果程序里需要导入多个包，可以每个包写一份`import`声明，也可以用`()`括起来，比如：

~~~go
import(
    "fmt"
    "os"
)
~~~

注释语句以`//`开头。按照惯例，在每个包的包声明前添加注释，对于`main package`，注释包含一句或几句话，从整体角度对程序做个描述。

`var`声明定义变量。变量会在声明时直接初始化。如果变量没有显示初始化，则被隐式地初始化成空字符串。

`:=`是短变量声明的一部分，这是定义一个或多个变量并根据他们的初始值为这些变量赋予适当类型的语句。

`++`和`--`是语句，不像C系的其他语言是表达式。所以`j=i++`非法，而且`++`和`–-`都只能放在变量名后面，因此`–-i`非法

Go语句只有`for`循环这一种循环语句。`for`循环有多种形式，其中一种如下：

~~~go
for initialization; condition; post{
    //zero or more statements
}
~~~

`for`循环的三个部分不需括号包围。大括号强制要求，左大括号必须和`post`语句在同一行。

`initialization`语句是可选的，在循环开始前执行。`initlization`如果存在，必须是一条简单语句，即短变量声明、自增语句、赋值语句或函数调用。`condition`是一个布尔表达式，其值在每次循环迭代开始时计算。`post`语句在循环体执行结束后执行，之后再次对`condition`求值。

`for`循环的这三个部分每个都可以被省略，如果省略`initlization`和`post`，分号也可以被省略：

~~~go
//a traditional "while" loop
for condition{
    //...
}
~~~

如果连`condition`也省略，可以这样

~~~go
//a traditional infinite loop
for{
    //...
}
~~~

这样就会变成无限循环。可以采用`break`或者`return`语句。

`for`循环的另一种形式，在某种数据类型的区间上遍历

~~~go
for index, arg := range os.Args[1:]{
    fmt.Println("下标：",index,"\t",arg)
}
~~~

每次循环迭代，`range`产生一对值：索引以及该索引处的元素值。由于Go语言不允许使用无用的局部变量，这样会导致编译错误。因此如果不想要用索引，可以采用空标识符，即`__`（下划线）。空标识符可用于任何语法需要变量名但程序逻辑不需要的时候，类似于C++的`std::ignore`。

声明变量的形式有：

~~~go
s := ""
var s string
var s = ""
var s string = ""
~~~
第一种是短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为“”。第三种形式用的少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式的某个，初始值重要地话就显式地指定变量的类型，否则使用隐式初始化。

`+=`连接字符串，产生新字符串，并把它赋值给`s`。`s`原来的内容不再使用，将在适当时机对它进行垃圾回收。如果连接设计的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用`strings`包的`join`函数：

~~~go
func main(){
    fmt.Println(strings.Join(os.Args[1:]," "))
}
~~~

另外，还可以直接输出切片：

~~~go
fmt.Println(os.Args[1:])
~~~

最后每个元素都放在一对方括号里。

